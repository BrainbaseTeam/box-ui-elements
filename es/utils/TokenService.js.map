{"version":3,"sources":["../../src/utils/TokenService.js"],"names":["TYPED_ID_FOLDER_PREFIX","TYPED_ID_FILE_PREFIX","error","Error","TokenService","id","tokenOrTokenFunction","undefined","startsWith","token","read","write","getToken","ids","Array","isArray","promises","map","typedId","getReadToken","Promise","all","tokens","tokenMap","forEach","index","resolve","every","itemId"],"mappings":"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","sourcesContent":["/**\n * @flow\n * @file An example of a token managing service\n * @author Box\n */\n\nimport { TYPED_ID_FOLDER_PREFIX, TYPED_ID_FILE_PREFIX } from '../constants';\nimport type { Token, TokenLiteral } from '../common/types/core';\n\nconst error = new Error(\n    'Bad id or auth token. ID should be typed id like file_123 or folder_123! Token should be a string or function.',\n);\n\nclass TokenService {\n    /**\n     * Function to fetch a single token. The user supplied token can either\n     * itself be a simple token or instead be a function that returns a promise.\n     * This promise then resolves to either a string/null/undefined token or\n     * a read/write token pair.\n     *\n     * @private\n     * @param {string} id - box item typed id\n     * @param {string} tokenOrTokenFunction - Optional token or token function\n     * @return {Promise} that resolves to a token\n     */\n    static async getToken(id: string, tokenOrTokenFunction: Token): Promise<?string> {\n        // Make sure we are getting typed ids\n        // Tokens should either be null or undefined or string or functions\n        // Anything else is not supported and throw error\n        if (\n            (tokenOrTokenFunction !== null &&\n                tokenOrTokenFunction !== undefined &&\n                typeof tokenOrTokenFunction !== 'string' &&\n                typeof tokenOrTokenFunction !== 'function') ||\n            (!id.startsWith(TYPED_ID_FOLDER_PREFIX) && !id.startsWith(TYPED_ID_FILE_PREFIX))\n        ) {\n            throw error;\n        }\n\n        // Token is a simple string or null or undefined\n        if (!tokenOrTokenFunction || typeof tokenOrTokenFunction === 'string') {\n            return tokenOrTokenFunction;\n        }\n\n        // Token is a function which returns a promise.\n        // Promise on resolution returns a string/null/undefined token or token pair.\n        const token = await tokenOrTokenFunction(id);\n        if (!token || typeof token === 'string' || (typeof token === 'object' && (token.read || token.write))) {\n            return token;\n        }\n\n        throw error;\n    }\n\n    /**\n     * Gets a string read token.\n     * Defaults to a simple token string.\n     *\n     * @public\n     * @param {string} id - box item typed id\n     * @param {Token} tokenOrTokenFunction - Optional token or token function\n     * @return {Promise} that resolves to a token\n     */\n    static async getReadToken(id: string, tokenOrTokenFunction: Token): Promise<?string> {\n        const token: TokenLiteral = await TokenService.getToken(id, tokenOrTokenFunction);\n        if (token && typeof token === 'object') {\n            return token.read;\n        }\n\n        return token;\n    }\n\n    /**\n     * Gets read tokens.\n     *\n     * @public\n     * @param {string|string[]} id - box item typed id(s)\n     * @param {Token} tokenOrTokenFunction - Token to use or token generation function\n     * @return {Promise} Promise that resolves with id to token map\n     */\n    static async getReadTokens(id: string | string[], tokenOrTokenFunction: Token): Promise<Object> {\n        const ids: string[] = Array.isArray(id) ? id : [id];\n        const promises: Promise<?string>[] = ids.map((typedId: string) =>\n            TokenService.getReadToken(typedId, tokenOrTokenFunction),\n        );\n        const tokens: (?string)[] = await Promise.all(promises);\n        const tokenMap = {};\n        tokens.forEach((token, index) => {\n            tokenMap[ids[index]] = token;\n        });\n        return Promise.resolve(tokenMap);\n    }\n\n    /**\n     * Gets a string write token.\n     * Defaults to either the read token or a simple token string.\n     *\n     * @public\n     * @param {string} id - box item typed id\n     * @param {string} tokenOrTokenFunction - Optional token or token function\n     * @return {Promise} that resolves to a token\n     */\n    static async getWriteToken(id: string, tokenOrTokenFunction: Token): Promise<?string> {\n        const token: TokenLiteral = await TokenService.getToken(id, tokenOrTokenFunction);\n        if (token && typeof token === 'object') {\n            return token.write || token.read;\n        }\n\n        return token;\n    }\n\n    /**\n     * Function to fetch and cache multiple tokens. The user supplied token can either\n     * itself be a simple token or instead be a function that returns a promise.\n     * This promise then resolves signifying requested tokens were cached.\n     *\n     * This function however does not return tokens as it is expected to only be used\n     * by the token generator to cache all tokens that may be needed in the future.\n     *\n     * @public\n     * @param {Array<string>} idd - box item typed ids\n     * @param {string} tokenOrTokenFunction - Optional token or token function\n     * @return {Promise<TokenMap>} that resolves to a token map\n     */\n    static async cacheTokens(ids: Array<string>, tokenOrTokenFunction: Token): Promise<void> {\n        // Make sure we are getting typed ids\n        // Tokens should either be null or undefined or string or functions\n        // Anything else is not supported and throw error\n        if (\n            (tokenOrTokenFunction !== null &&\n                tokenOrTokenFunction !== undefined &&\n                typeof tokenOrTokenFunction !== 'string' &&\n                typeof tokenOrTokenFunction !== 'function') ||\n            !ids.every(itemId => itemId.startsWith(TYPED_ID_FOLDER_PREFIX) || itemId.startsWith(TYPED_ID_FILE_PREFIX))\n        ) {\n            throw error;\n        }\n\n        // Only need to fetch and cache multiple tokens when the user supplied token was a\n        // token function. This function should internally cache the tokens for future use.\n        if (typeof tokenOrTokenFunction === 'function') {\n            await tokenOrTokenFunction(ids);\n        }\n\n        return Promise.resolve();\n    }\n}\n\nexport default TokenService;\n"],"file":"TokenService.js"}