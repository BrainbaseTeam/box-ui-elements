{"version":3,"sources":["../../src/utils/Xhr.js"],"names":["axios","getProp","includes","lowerCase","TokenService","HEADER_ACCEPT","HEADER_ACCEPT_LANGUAGE","HEADER_CLIENT_NAME","HEADER_CLIENT_VERSION","HEADER_CONTENT_TYPE","HTTP_GET","HTTP_POST","HTTP_PUT","HTTP_DELETE","HTTP_OPTIONS","HTTP_HEAD","HTTP_STATUS_CODE_RATE_LIMIT","DEFAULT_UPLOAD_TIMEOUT_MS","MAX_NUM_RETRIES","RETRYABLE_HTTP_METHODS","map","Xhr","id","clientName","language","token","version","sharedLink","sharedLinkPassword","responseInterceptor","requestInterceptor","retryableStatusCodes","shouldRetry","error","shouldRetryRequest","retryCount","delay","getExponentialRetryTimeoutInMs","Promise","resolve","reject","retryTimeout","setTimeout","config","then","errorObject","defaultResponseInterceptor","create","axiosSource","CancelToken","source","interceptors","response","use","errorInterceptor","request","status","method","isNetworkError","isRateLimitError","isOtherRetryableError","numRetries","randomizationMs","Math","ceil","random","exponentialMs","url","a","document","createElement","href","api","replace","origin","host","hostname","pathname","protocol","hash","port","args","headers","Accept","BoxApi","itemId","getWriteToken","Authorization","params","getHeaders","hdrs","get","cancelToken","parsedUrl","getParsedUrl","data","post","successHandler","errorHandler","catch","progressHandler","withIdleTimeout","idleTimeoutDuration","idleTimeoutHandler","idleTimeout","progressHandlerToUse","idleTimeoutFunc","abort","event","clearTimeout","transformRequest","reqData","reqHeaders","Blob","attributes","formData","FormData","Object","keys","forEach","key","append","onUploadProgress","cancel"],"mappings":"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","sourcesContent":["/**\n * @flow\n * @file Network utilities\n * @author Box\n */\n\nimport axios from 'axios';\nimport type { $AxiosError, $AxiosXHR } from 'axios';\nimport getProp from 'lodash/get';\nimport includes from 'lodash/includes';\nimport lowerCase from 'lodash/lowerCase';\nimport TokenService from './TokenService';\nimport {\n    HEADER_ACCEPT,\n    HEADER_ACCEPT_LANGUAGE,\n    HEADER_CLIENT_NAME,\n    HEADER_CLIENT_VERSION,\n    HEADER_CONTENT_TYPE,\n    HTTP_GET,\n    HTTP_POST,\n    HTTP_PUT,\n    HTTP_DELETE,\n    HTTP_OPTIONS,\n    HTTP_HEAD,\n    HTTP_STATUS_CODE_RATE_LIMIT,\n} from '../constants';\nimport type { APIOptions, Method, PayloadType, RequestData } from '../common/types/api';\nimport type { StringAnyMap, StringMap, Token } from '../common/types/core';\n\nconst DEFAULT_UPLOAD_TIMEOUT_MS = 120000;\nconst MAX_NUM_RETRIES = 3;\nconst RETRYABLE_HTTP_METHODS = [HTTP_GET, HTTP_OPTIONS, HTTP_HEAD].map(lowerCase);\n\nclass Xhr {\n    id: ?string;\n\n    axios: Axios;\n\n    axiosSource: CancelTokenSource;\n\n    clientName: ?string;\n\n    language: ?string;\n\n    token: Token;\n\n    version: ?string;\n\n    sharedLink: ?string;\n\n    sharedLinkPassword: ?string;\n\n    xhr: XMLHttpRequest;\n\n    responseInterceptor: Function;\n\n    requestInterceptor: ?Function;\n\n    tokenService: TokenService;\n\n    retryCount: number = 0;\n\n    retryableStatusCodes: Array<number>;\n\n    retryTimeout: ?TimeoutID;\n\n    shouldRetry: boolean;\n\n    /**\n     * [constructor]\n     *\n     * @param {Object} options\n     * @param {string} options.id - item id\n     * @param {string} options.clientName - Client Name\n     * @param {string|function} options.token - Auth token\n     * @param {string} [options.language] - Accept-Language header value\n     * @param {string} [options.sharedLink] - Shared link\n     * @param {string} [options.sharedLinkPassword] - Shared link password\n     * @param {string} [options.requestInterceptor] - Request interceptor\n     * @param {string} [options.responseInterceptor] - Response interceptor\n     * @param {number[]} [options.retryableStatusCodes] - Response codes to retry\n     * @param {boolean} [options.shouldRetry] - Should retry failed requests\n     * @return {Xhr} Cache instance\n     */\n    constructor({\n        id,\n        clientName,\n        language,\n        token,\n        version,\n        sharedLink,\n        sharedLinkPassword,\n        responseInterceptor,\n        requestInterceptor,\n        retryableStatusCodes = [HTTP_STATUS_CODE_RATE_LIMIT],\n        shouldRetry = true,\n    }: APIOptions = {}) {\n        this.clientName = clientName;\n        this.id = id;\n        this.language = language;\n        this.responseInterceptor = responseInterceptor || this.defaultResponseInterceptor;\n        this.retryableStatusCodes = retryableStatusCodes;\n        this.sharedLink = sharedLink;\n        this.sharedLinkPassword = sharedLinkPassword;\n        this.shouldRetry = shouldRetry;\n        this.token = token;\n        this.version = version;\n\n        this.axios = axios.create();\n        this.axiosSource = axios.CancelToken.source();\n        this.axios.interceptors.response.use(this.responseInterceptor, this.errorInterceptor);\n\n        if (typeof requestInterceptor === 'function') {\n            this.axios.interceptors.request.use(requestInterceptor);\n        }\n    }\n\n    /**\n     * Default response interceptor which just returns the response\n     *\n     * @param {Object} response - the axios response\n     * @return the response\n     */\n    defaultResponseInterceptor(response: $AxiosXHR<any>) {\n        return response;\n    }\n\n    /**\n     * Determines if a request should be retried\n     *\n     * @param {Object} error - Error object from axios\n     * @return {boolean} true if the request should be retried\n     */\n    shouldRetryRequest(error: $AxiosError<any>): boolean {\n        if (!this.shouldRetry || this.retryCount >= MAX_NUM_RETRIES) {\n            return false;\n        }\n\n        const { response, request, config } = error;\n        // Retry if there is a network error (e.g. ECONNRESET) or rate limited\n        const status = getProp(response, 'status');\n        const method = getProp(config, 'method');\n        const isNetworkError = request && !response;\n        const isRateLimitError = status === HTTP_STATUS_CODE_RATE_LIMIT;\n        const isOtherRetryableError =\n            includes(this.retryableStatusCodes, status) && includes(RETRYABLE_HTTP_METHODS, method);\n        return isNetworkError || isRateLimitError || isOtherRetryableError;\n    }\n\n    /**\n     * Calculate the exponential backoff time with randomized jitter.\n     *\n     * @param {number} numRetries Which retry number this one will be. Must be > 0\n     * @returns {number} The number of milliseconds after which to retry\n     */\n    getExponentialRetryTimeoutInMs(numRetries: number): number {\n        const randomizationMs = Math.ceil(Math.random() * 1000);\n        const exponentialMs = 2 ** (numRetries - 1) * 1000;\n        return exponentialMs + randomizationMs;\n    }\n\n    /**\n     * Error interceptor that wraps the passed in responseInterceptor\n     *\n     * @param {Object} error - Error object from axios\n     * @return {Promise} rejected promise with error info\n     */\n    errorInterceptor = (error: $AxiosError<any>): Promise<any> => {\n        const shouldRetry = this.shouldRetryRequest(error);\n        if (shouldRetry) {\n            this.retryCount += 1;\n            const delay = this.getExponentialRetryTimeoutInMs(this.retryCount);\n            return new Promise((resolve, reject) => {\n                this.retryTimeout = setTimeout(() => {\n                    this.axios(error.config).then(resolve, reject);\n                }, delay);\n            });\n        }\n\n        const errorObject = getProp(error, 'response.data') || error; // In the case of 401, response.data is empty so fall back to error\n        this.responseInterceptor(errorObject);\n\n        return Promise.reject(error);\n    };\n\n    /**\n     * Utility to parse a URL.\n     *\n     * @param {string} url - Url to parse\n     * @return {Object} parsed url\n     */\n    getParsedUrl(url: string) {\n        const a = document.createElement('a');\n        a.href = url;\n        return {\n            api: url.replace(`${a.origin}/2.0`, ''),\n            host: a.host,\n            hostname: a.hostname,\n            pathname: a.pathname,\n            origin: a.origin,\n            protocol: a.protocol,\n            hash: a.hash,\n            port: a.port,\n        };\n    }\n\n    /**\n     * Builds a list of required XHR headers.\n     *\n     * @param {string} [id] - Optional box item id\n     * @param {Object} [args] - Optional existing headers\n     * @return {Object} Headers\n     */\n    async getHeaders(id?: string, args: StringMap = {}) {\n        const headers: StringMap = {\n            Accept: 'application/json',\n            [HEADER_CONTENT_TYPE]: 'application/json',\n            ...args,\n        };\n\n        if (this.language && !headers[HEADER_ACCEPT_LANGUAGE]) {\n            headers[HEADER_ACCEPT_LANGUAGE] = this.language;\n        }\n\n        if (this.sharedLink) {\n            headers.BoxApi = `shared_link=${this.sharedLink}`;\n\n            if (this.sharedLinkPassword) {\n                headers.BoxApi = `${headers.BoxApi}&shared_link_password=${this.sharedLinkPassword}`;\n            }\n        }\n\n        if (this.clientName) {\n            headers[HEADER_CLIENT_NAME] = this.clientName;\n        }\n\n        if (this.version) {\n            headers[HEADER_CLIENT_VERSION] = this.version;\n        }\n\n        // If id is passed in, use that, otherwise default to this.id\n        const itemId = id || this.id || '';\n        const token = await TokenService.getWriteToken(itemId, this.token);\n        if (token) {\n            // Only add a token when there was one found\n            headers.Authorization = `Bearer ${token}`;\n        }\n\n        return headers;\n    }\n\n    /**\n     * HTTP GETs a URL\n     *\n     * @param {string} id - Box item id\n     * @param {string} url - The URL to fetch\n     * @param {Object} [headers] - Key-value map of headers\n     * @param {Object} [params] - Key-value map of querystring params\n     * @return {Promise} - HTTP response\n     */\n    get({\n        url,\n        id,\n        params = {},\n        headers = {},\n    }: {\n        headers?: StringMap,\n        id?: string,\n        params?: StringAnyMap,\n        url: string,\n    }): Promise<StringAnyMap> {\n        return this.getHeaders(id, headers).then(hdrs =>\n            this.axios.get(url, {\n                cancelToken: this.axiosSource.token,\n                params,\n                headers: hdrs,\n                parsedUrl: this.getParsedUrl(url),\n            }),\n        );\n    }\n\n    /**\n     * HTTP POSTs a URL with JSON data\n     *\n     * @param {string} id - Box item id\n     * @param {string} url - The URL to fetch\n     * @param {Object} data - JS Object representation of JSON data to send\n     * @param {Object} params - Optional query params for the request\n     * @param {Object} [headers] - Key-value map of headers\n     * @param {string} [method] - xhr type\n     * @return {Promise} - HTTP response\n     */\n    post({\n        url,\n        id,\n        data,\n        params,\n        headers = {},\n        method = HTTP_POST,\n    }: {\n        data: PayloadType,\n        headers?: StringMap,\n        id?: string,\n        method?: Method,\n        params?: StringAnyMap,\n        url: string,\n    }): Promise<StringAnyMap> {\n        return this.getHeaders(id, headers).then(hdrs =>\n            this.axios({\n                url,\n                data,\n                params,\n                method,\n                parsedUrl: this.getParsedUrl(url),\n                headers: hdrs,\n            }),\n        );\n    }\n\n    /**\n     * HTTP PUTs a URL with JSON data\n     *\n     * @param {string} id - Box item id\n     * @param {string} url - The URL to fetch\n     * @param {Object} data - JS Object representation of JSON data to send\n     * @param {Object} params - Optional query params for the request\n     * @param {Object} [headers] - Key-value map of headers\n     * @return {Promise} - HTTP response\n     */\n    put({ url, id, data, params, headers = {} }: RequestData): Promise<StringAnyMap> {\n        return this.post({ id, url, data, params, headers, method: HTTP_PUT });\n    }\n\n    /**\n     * HTTP DELETEs a URL with JSON data\n     *\n     * @param {string} id - Box item id\n     * @param {string} url - The URL to fetch\n     * @param {Object} data - JS Object representation of JSON data to send\n     * @param {Object} [headers] - Key-value map of headers\n     * @return {Promise} - HTTP response\n     */\n    delete({\n        url,\n        id,\n        data = {},\n        headers = {},\n    }: {\n        data?: StringAnyMap,\n        headers?: StringMap,\n        id?: string,\n        url: string,\n    }): Promise<StringAnyMap> {\n        return this.post({ id, url, data, headers, method: HTTP_DELETE });\n    }\n\n    /**\n     * HTTP OPTIONs a URL with JSON data.\n     *\n     * @param {string} id - Box item id\n     * @param {string} url - The URL to post to\n     * @param {Object} data - The non-file post data that should accompany the post\n     * @param {Object} [headers] - Key-value map of headers\n     * @param {Function} successHandler - Load success handler\n     * @param {Function} errorHandler - Error handler\n     * @return {void}\n     */\n    options({\n        id,\n        url,\n        data,\n        headers = {},\n        successHandler,\n        errorHandler,\n    }: {\n        data: StringAnyMap,\n        errorHandler: Function,\n        headers?: StringMap,\n        id?: string,\n        progressHandler?: Function,\n        successHandler: Function,\n        url: string,\n    }): Promise<StringAnyMap> {\n        return this.getHeaders(id, headers)\n            .then(hdrs =>\n                this.axios({\n                    url,\n                    data,\n                    method: HTTP_OPTIONS,\n                    headers: hdrs,\n                })\n                    .then(successHandler)\n                    .catch(errorHandler),\n            )\n            .catch(errorHandler);\n    }\n\n    /**\n     * HTTP POST or PUT a URL with File data. Uses native XHR for progress event.\n     *\n     * @param {string} id - Box item id\n     * @param {string} url - The URL to post to\n     * @param {Object} [data] - File data and attributes\n     * @param {Object} [headers] - Key-value map of headers\n     * @param {string} [method] - XHR method, supports 'POST' and 'PUT'\n     * @param {Function} successHandler - Load success handler\n     * @param {Function} errorHandler - Error handler\n     * @param {Function} progressHandler - Progress handler\n     * @param {boolean} [withIdleTimeout] - enable idle timeout\n     * @param {number} [idleTimeoutDuration] - idle timeout duration\n     * @param {Function} [idleTimeoutHandler]\n     * @return {void}\n     */\n    uploadFile({\n        id,\n        url,\n        data,\n        headers = {},\n        method = HTTP_POST,\n        successHandler,\n        errorHandler,\n        progressHandler,\n        withIdleTimeout = false,\n        idleTimeoutDuration = DEFAULT_UPLOAD_TIMEOUT_MS,\n        idleTimeoutHandler,\n    }: {\n        data?: ?Blob | ?StringAnyMap,\n        errorHandler: Function,\n        headers?: StringMap,\n        id?: string,\n        idleTimeoutDuration?: number,\n        idleTimeoutHandler?: Function,\n        method?: Method,\n        progressHandler: Function,\n        successHandler: Function,\n        url: string,\n        withIdleTimeout?: boolean,\n    }): Promise<any> {\n        return this.getHeaders(id, headers)\n            .then(hdrs => {\n                let idleTimeout;\n                let progressHandlerToUse = progressHandler;\n\n                if (withIdleTimeout) {\n                    // Func that aborts upload and executes timeout callback\n                    const idleTimeoutFunc = () => {\n                        this.abort();\n\n                        if (idleTimeoutHandler) {\n                            idleTimeoutHandler();\n                        }\n                    };\n\n                    idleTimeout = setTimeout(idleTimeoutFunc, idleTimeoutDuration);\n\n                    // Progress handler that aborts upload if there has been no progress for >= timeoutMs\n                    progressHandlerToUse = event => {\n                        clearTimeout(idleTimeout);\n                        idleTimeout = setTimeout(idleTimeoutFunc, idleTimeoutDuration);\n                        progressHandler(event);\n                    };\n                }\n                this.axios({\n                    url,\n                    data,\n                    transformRequest: (reqData, reqHeaders) => {\n                        // Remove Accept & Content-Type added by getHeaders()\n                        delete reqHeaders[HEADER_ACCEPT];\n                        delete reqHeaders[HEADER_CONTENT_TYPE];\n\n                        if (headers[HEADER_CONTENT_TYPE]) {\n                            reqHeaders[HEADER_CONTENT_TYPE] = headers[HEADER_CONTENT_TYPE];\n                        }\n\n                        // Convert to FormData if needed\n                        if (reqData && !(reqData instanceof Blob) && reqData.attributes) {\n                            const formData = new FormData();\n                            Object.keys(reqData).forEach(key => {\n                                formData.append(key, reqData[key]);\n                            });\n\n                            return formData;\n                        }\n\n                        return reqData;\n                    },\n                    method,\n                    headers: hdrs,\n                    onUploadProgress: progressHandlerToUse,\n                    cancelToken: this.axiosSource.token,\n                })\n                    .then(response => {\n                        clearTimeout(idleTimeout);\n                        successHandler(response);\n                    })\n                    .catch(error => {\n                        clearTimeout(idleTimeout);\n                        errorHandler(error);\n                    });\n            })\n            .catch(errorHandler);\n    }\n\n    /**\n     * Aborts an axios request.\n     *\n     * @return {void}\n     */\n    abort(): void {\n        if (this.retryTimeout) {\n            clearTimeout(this.retryTimeout);\n        }\n        if (this.axiosSource) {\n            this.axiosSource.cancel();\n            this.axiosSource = axios.CancelToken.source();\n        }\n    }\n}\n\nexport default Xhr;\n"],"file":"Xhr.js"}