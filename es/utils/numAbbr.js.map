{"version":3,"sources":["../../src/utils/numAbbr.ts"],"names":["IntlMessageFormat","data","isNaN","languages","numbers","Lengths","numAbbrWithLocale","input","options","numbersData","locale","length","short","exponent","Math","floor","toString","formats","digits","count","round","template","msg","format","numAbbr","bcp47Tag","value","parseInt","Array","isArray","map","element"],"mappings":"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","sourcesContent":["/**\n * @file Function to abbreviate a number as a string in a locale-sensitive manner.\n * @author Box\n */\n\nimport IntlMessageFormat from 'intl-messageformat';\nimport data, { NumbersData } from 'box-locale-data';\n\nimport isNaN from 'lodash/isNaN';\n\nconst { languages, numbers } = data;\n\nexport enum Lengths {\n    short = 'short',\n    long = 'long',\n}\n\nexport interface NumAbbrOptions {\n    length?: Lengths;\n    locale?: string;\n    numbersData?: NumbersData;\n}\n\nfunction numAbbrWithLocale(input: number, options: NumAbbrOptions, numbersData?: NumbersData, locale?: string): string {\n    if (!input || !numbersData) {\n        return '0';\n    }\n    let { length }: { length?: Lengths } = options;\n    length = length || Lengths.short;\n    let exponent: number = Math.floor(input).toString().length - 1;\n    if (input < 0) {\n        exponent -= 1; // take care of the negative sign\n    }\n    const formats = numbersData[length];\n    const digits: number = exponent >= formats.length ? exponent - formats.length + 3 : formats[exponent].digits;\n    const count: number = Math.round(input / 10 ** (exponent - digits + 1));\n    const template = new IntlMessageFormat(\n        formats[exponent > formats.length ? formats.length - 1 : exponent].msg,\n        locale,\n    );\n    return template.format({ count });\n}\n\n/**\n * Gets the number in abbreviated form in a locale-sensitive manner. This function\n * scales the number down to the smallest it can be, taking only up to 4 significant\n * digits, and rounding the rest. ie. 12345678 becomes \"12M\" in English.\n *\n * The abbreviation words/letters can have the length \"short\" or \"long\", specified\n * with the \"length\" property in the options. If \"short\",\n * then this function uses an abbreviation of the bucket such as \"12M\". If \"long\",\n * then the name of the bucket is written out in full, such as \"12 million\".\n *\n * For locales that have complex plurals, such as Russian or Polish, this function\n * returns the correctly pluralized suffix/prefix to go along with the scaled number.\n */\nfunction numAbbr(input: unknown, options: NumAbbrOptions = { length: Lengths.short }): string | string[] {\n    if (!input) return '0';\n\n    // languages contains info about the current locale\n    const { locale = languages.bcp47Tag || 'en-US', numbersData = numbers }: NumAbbrOptions = options;\n    let value;\n\n    switch (typeof input) {\n        case 'boolean':\n            input = input ? 1 : 0;\n            break;\n\n        case 'string':\n            value = parseInt(input, 10);\n            if (isNaN(value)) {\n                return '0';\n            }\n            break;\n\n        case 'object':\n            // for an array, we format each element of that array. In order to do that safely,\n            // recursively call numAbbr to make sure each of the elements is converted to a\n            // number before we call numAbbrWithLocale\n            return Array.isArray(input)\n                ? input.map((element: unknown) => {\n                      return numAbbr(element, options) as string;\n                  })\n                : '0';\n\n        default:\n            break;\n    }\n\n    return numAbbrWithLocale(input as number, options, numbersData, locale);\n}\n\nexport default numAbbr;\n"],"file":"numAbbr.js"}