{"version":3,"sources":["../../src/utils/datetime.js"],"names":["isNaN","MILLISECONDS_PER_SECOND","MILLISECONDS_PER_DAY","MILLISECONDS_PER_MINUTE","RE_ISO8601_DATE","ISO8601_DATETIME","ISO8601_MILLISECONDS","ISO8601_TIMEZONE","ISO8601_Z_FMT","ISO8601_SHORT_FMT","ISO8601_MEDIUM_FMT","ISO8601_LONG_FMT","convertToDate","dateValue","Date","convertToMs","seconds","isToday","toDateString","isYesterday","getTime","isTomorrow","isCurrentMonth","getMonth","isCurrentYear","getFullYear","formatTime","h","Math","floor","m","s","hour","toString","sec","min","addTime","timeToAdd","convertDateToUnixMidnightTime","date","utcUnixTimeInMs","timezoneOffsetInMins","getTimezoneOffset","timezoneOffsetInMs","unixDayMidnightTime","isValidDate","convertISOStringtoRFC3339String","isoString","test","parseDate","split","dateTime","milliseconds","timeZone","substr","convertISOStringToUTCDate","utcDate","utcTime","localizedUnixTimeInMs"],"mappings":"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","sourcesContent":["/**\n * @flow\n * @file Date and time utilities\n * @author Box\n */\nimport isNaN from 'lodash/isNaN';\n\nconst MILLISECONDS_PER_SECOND = 1000;\n// 24 hours * 60 minutes * 60 seconds * 1000 milliseconds\nconst MILLISECONDS_PER_DAY = 24 * 60 * 60 * MILLISECONDS_PER_SECOND;\n// 60 sec * 1000\nconst MILLISECONDS_PER_MINUTE = 60 * MILLISECONDS_PER_SECOND;\n\n/**\n * RegExp matcher for acceptable ISO 8601 date formats w/ timezone (see below)\n * Capture groups structured as follows:\n * 1) the date/time portion (2018-06-13T00:00:00.000)\n * 2) the milliseconds (if matched)\n * 3) the timezone portion (e.g., Z, +03, -0400, +05:00)\n * 4) the Z format for timezone (if matched)\n * 5) the short format for timezone (if matched)\n * 6) the colon-less format for timezone (if matched)\n * 7) the colon long format for timezone (if matched)\n */\nconst RE_ISO8601_DATE = /^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d{1,3})?)?((Z$)|(?:[+-](?:([0-2]\\d$)|([0-2]\\d(?:00|30)$)|([0-2]\\d:(?:00|30)$))))$/;\nconst ISO8601_DATETIME: 1 = 1;\nconst ISO8601_MILLISECONDS: 2 = 2;\nconst ISO8601_TIMEZONE: 3 = 3;\nconst ISO8601_Z_FMT: 4 = 4;\nconst ISO8601_SHORT_FMT: 5 = 5;\nconst ISO8601_MEDIUM_FMT: 6 = 6;\nconst ISO8601_LONG_FMT: 7 = 7;\n\n/**\n * Helper to normalize a date value to a date object\n * @param dateValue - Date number, string, or object\n * @returns {date} the normalized date object\n */\nfunction convertToDate(dateValue: number | string | Date): Date {\n    return dateValue instanceof Date ? dateValue : new Date(dateValue);\n}\n\n/**\n * Converts an integer value in seconds to milliseconds.\n * @param {number} seconds - The value in seconds\n * @returns {number} the value in milliseconds\n */\nfunction convertToMs(seconds: number): number {\n    return seconds * MILLISECONDS_PER_SECOND;\n}\n\n/**\n * Checks whether the given date value (in unix milliseconds) is today.\n * @param {number|string|Date} dateValue - Date object or integer representing the number of milliseconds since 1/1/1970 UTC\n * @returns {boolean} whether the given value is today\n */\nfunction isToday(dateValue: number | string | Date): boolean {\n    return new Date().toDateString() === convertToDate(dateValue).toDateString();\n}\n\n/**\n * Checks whether the given date value (in unix milliseconds) is yesterday.\n * @param {number|string|Date} dateValue - Date object or integer or representing the number of milliseconds since 1/1/1970 UTC\n * @returns {boolean} whether the given value is yesterday\n */\nfunction isYesterday(dateValue: number | string | Date): boolean {\n    return isToday(convertToDate(dateValue).getTime() + MILLISECONDS_PER_DAY);\n}\n\n/**\n * Checks whether the given date value (in unix milliseconds) is tomorrow.\n * @param {number|string|Date} dateValue - Date object or integer or representing the number of milliseconds since 1/1/1970 UTC\n * @returns {boolean} whether the given value is tomorrow\n */\nfunction isTomorrow(dateValue: number | string | Date): boolean {\n    return isToday(convertToDate(dateValue).getTime() - MILLISECONDS_PER_DAY);\n}\n\n/**\n * Checks whether the given date value (in unix milliseconds) is in the current month.\n * @param {number|string|Date} dateValue - Date object or integer representing the number of milliseconds since 1/1/1970 UTC\n * @returns {boolean} whether the given value is in the current month\n */\nfunction isCurrentMonth(dateValue: number | string | Date): boolean {\n    return new Date().getMonth() === convertToDate(dateValue).getMonth();\n}\n\n/**\n * Checks whether the given date value (in unix milliseconds) is in the current year.\n * @param {number|string|Date} dateValue - Date object or integer representing the number of milliseconds since 1/1/1970 UTC\n * @returns {boolean} whether the given value is in the current year\n */\nfunction isCurrentYear(dateValue: number | string | Date): boolean {\n    return new Date().getFullYear() === convertToDate(dateValue).getFullYear();\n}\n\n/**\n * Formats a number of seconds as a time string\n *\n * @param {number} seconds - seconds\n * @return {string} a string formatted like 3:57:35\n */\nfunction formatTime(seconds: number): string {\n    const h = Math.floor(seconds / 3600);\n    const m = Math.floor((seconds % 3600) / 60);\n    const s = Math.floor((seconds % 3600) % 60);\n    const hour = h > 0 ? `${h.toString()}:` : '';\n    const sec = s < 10 ? `0${s.toString()}` : s.toString();\n    let min = m.toString();\n    if (h > 0 && m < 10) {\n        min = `0${min}`;\n    }\n    return `${hour}${min}:${sec}`;\n}\n\n/**\n * Adds time to a given dateValue\n *\n * @param {number|Date} dateValue - date or integer value to add time to\n * @param {number} timeToAdd - amount of time to add in ms\n * @return {number|Date} the modified date or integer\n */\nfunction addTime(dateValue: number | Date, timeToAdd: number): number | Date {\n    if (dateValue instanceof Date) {\n        return new Date(dateValue.getTime() + timeToAdd);\n    }\n\n    return dateValue + timeToAdd;\n}\n\n/**\n * Will convert\n *      2018-06-13T07:00:00.000Z\n * to\n *      2018-06-13T00:00:00.000Z\n *\n * This is the opposite of convertISOStringToUTCDate\n *\n * @param {Date} date\n * @return {number}\n */\nfunction convertDateToUnixMidnightTime(date: Date) {\n    // date is localized to 00:00:00 at system/browser timezone\n    const utcUnixTimeInMs = date.getTime();\n\n    // timezone an integer offset; minutes behind GMT\n    // we use the browser timezone offset instead of the user's,\n    // because the datepicker uses the browser to get the \"midnight\"\n    // time in the user's timezone with getTime()\n    const timezoneOffsetInMins = date.getTimezoneOffset();\n    const timezoneOffsetInMs = timezoneOffsetInMins * MILLISECONDS_PER_MINUTE;\n\n    // we need the unix/epoch time for midnight on the date selected\n    const unixDayMidnightTime = utcUnixTimeInMs - timezoneOffsetInMs;\n    return unixDayMidnightTime;\n}\n\n/**\n * Will check to see if a date object is not valid, according to the browser\n * JS engine.\n *\n * @param {Date} date\n * @return {boolean} whether the date value passes validation\n */\nfunction isValidDate(date: Date): boolean {\n    return !isNaN(date.getTime());\n}\n\n/**\n * Will convert ISO8601-compatible dates (with zone designators)\n *      2018-06-13T00:00:00.000-0500\n *      or\n *      2018-06-13T00:00:00.000-05\n *\n * to\n *      2018-06-13T00:00:00.000-05:00\n *\n * Equivalent formats between the two (e.g., uzing 'Z') will remain unchanged.\n * If the date format cannot be converted, it will pass along the existing value\n * @param {string} isoString\n * @return {string} converted date format, if applicable\n */\nfunction convertISOStringtoRFC3339String(isoString: string): string {\n    // test that the date format inbound is ISO8601-compatible\n    if (RE_ISO8601_DATE.test(isoString)) {\n        // if it is, parse out the timezone part if it's in a longer format\n        // use the capture groups instead of the split result for the datetime and the time zone\n        const parseDate = isoString.split(RE_ISO8601_DATE);\n        let dateTime = parseDate[ISO8601_DATETIME];\n        const milliseconds = parseDate[ISO8601_MILLISECONDS];\n        const timeZone = parseDate[ISO8601_TIMEZONE];\n\n        // add milliseconds if missing, to standardize output\n        if (!milliseconds) {\n            dateTime += '.000';\n        }\n\n        if (parseDate[ISO8601_Z_FMT]) {\n            return isoString;\n        }\n\n        if (parseDate[ISO8601_SHORT_FMT]) {\n            return `${dateTime + timeZone}:00`;\n        }\n\n        if (parseDate[ISO8601_MEDIUM_FMT]) {\n            return `${dateTime + timeZone.substr(0, 3)}:${timeZone.substr(3)}`;\n        }\n\n        if (parseDate[ISO8601_LONG_FMT]) {\n            return isoString;\n        }\n    }\n    return isoString;\n}\n\n/**\n * Will convert\n *      2018-06-13T00:00:00.000Z\n * to\n *      2018-06-13T07:00:00.000Z\n *\n * This is the opposite of convertDateToUnixMidnightTime\n *\n * @param {string} isoString - ISO string in UTC time zone\n */\nfunction convertISOStringToUTCDate(isoString: string): Date {\n    // get date in UTC midnight time\n    const utcDate = new Date(convertISOStringtoRFC3339String(isoString));\n    const utcTime = utcDate.getTime();\n\n    // get browser's timezone\n    const timezoneOffsetInMins = utcDate.getTimezoneOffset();\n    const timezoneOffsetInMs = timezoneOffsetInMins * MILLISECONDS_PER_MINUTE;\n\n    // return date in utc timezone\n    const localizedUnixTimeInMs = utcTime + timezoneOffsetInMs;\n    return new Date(localizedUnixTimeInMs);\n}\n\nexport {\n    convertToDate,\n    convertToMs,\n    convertDateToUnixMidnightTime,\n    convertISOStringToUTCDate,\n    convertISOStringtoRFC3339String,\n    isToday,\n    isTomorrow,\n    isValidDate,\n    isYesterday,\n    isCurrentMonth,\n    isCurrentYear,\n    formatTime,\n    addTime,\n};\n"],"file":"datetime.js"}