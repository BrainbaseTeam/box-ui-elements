{"version":3,"sources":["../../src/utils/fuzzySearch.js"],"names":["fuzzySearch","search","content","minCharacters","maxGaps","uniformContent","toLowerCase","replace","uniformSearch","contentLength","length","searchLength","matched","totalScore","i","searchIndex","currentScore","subScore","j","maxGroups","Math","min","minScore","max","floor"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;AAoBA,IAAMA,WAAW,GAAG,SAAdA,WAAc,CAACC,MAAD,EAAiBC,OAAjB,EAA+F;AAAA,MAA5DC,aAA4D,uEAApC,CAAoC;AAAA,MAAjCC,OAAiC,uEAAf,CAAe;;AAC/G,MAAI,CAACF,OAAL,EAAc;AACV,WAAO,KAAP;AACH;;AACD,MAAMG,cAAc,GAAGH,OAAO,CAACI,WAAR,GAAsBC,OAAtB,CAA8B,KAA9B,EAAqC,EAArC,CAAvB;AACA,MAAMC,aAAa,GAAGP,MAAM,CAACK,WAAP,GAAqBC,OAArB,CAA6B,KAA7B,EAAoC,EAApC,CAAtB;AACA,MAAME,aAAa,GAAGJ,cAAc,CAACK,MAArC;AACA,MAAMC,YAAY,GAAGH,aAAa,CAACE,MAAnC;;AACA,MAAIC,YAAY,GAAGR,aAAf,IAAgCQ,YAAY,GAAGF,aAAnD,EAAkE;AAC9D,WAAO,KAAP;AACH;;AACD,MAAIG,OAAO,GAAG,KAAd;AACA,MAAIC,UAAU,GAAG,CAAjB;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,aAApB,EAAmCK,CAAC,IAAI,CAAxC,EAA2C;AACvC,QAAIL,aAAa,GAAGK,CAAhB,GAAoBH,YAAxB,EAAsC;AAClC;AACH;;AACD,QAAII,WAAW,GAAG,CAAlB;AACA,QAAIC,YAAY,GAAG,CAAnB;AACA,QAAIC,QAAQ,GAAG,CAAf;;AACA,SAAK,IAAIC,CAAC,GAAGJ,CAAb,EAAgBI,CAAC,GAAGT,aAApB,EAAmCS,CAAC,IAAI,CAAxC,EAA2C;AACvC,UAAIb,cAAc,CAACa,CAAD,CAAd,KAAsBV,aAAa,CAACO,WAAD,CAAvC,EAAsD;AAClDA,QAAAA,WAAW,IAAI,CAAf,CADkD,CAElD;;AACAC,QAAAA,YAAY,IAAI,IAAIA,YAApB;AACH,OAJD,MAIO;AACHA,QAAAA,YAAY,GAAG,CAAf;AACH;;AACDC,MAAAA,QAAQ,IAAID,YAAZ;AACH;;AACD,QAAID,WAAW,KAAKJ,YAApB,EAAkC;AAC9B;AACH;;AACD,QAAIM,QAAQ,GAAGJ,UAAf,EAA2B;AACvBA,MAAAA,UAAU,GAAGI,QAAb;AACH;AACJ;;AACD,MAAIJ,UAAU,GAAG,CAAjB,EAAoB;AAChB,QAAMM,SAAS,GAAGC,IAAI,CAACC,GAAL,CAASjB,OAAT,EAAkBO,YAAlB,CAAlB,CADgB,CAEhB;AACA;AACA;;AACA,QAAMW,QAAQ,GAAGF,IAAI,CAACG,GAAL,CAASJ,SAAS,YAAG,CAAH,EAAQC,IAAI,CAACI,KAAL,CAAWb,YAAY,GAAGQ,SAAf,GAA2B,CAAtC,CAAR,CAAlB,EAAoER,YAAY,GAAG,CAAnF,CAAjB;AACAC,IAAAA,OAAO,GAAGC,UAAU,IAAIS,QAAxB;AACH;;AACD,SAAOV,OAAP;AACH,CA9CD;;AAgDA,eAAeZ,WAAf","sourcesContent":["/**\n * @flow\n * @file Fuzzy search utility\n * @author Box\n *\n\n/**\n * Fuzzy search helper to match a term against a piece of content.\n * Matches all characters in search string to content in the order they appear.\n * Requires all characters to be matched in order to return true.\n * Internal scoring rewards sequences of characters found in the content very highly.\n * Also has a minimum scoring check the uses the passed maxGaps to approximate how many breaks in the\n * search string are allowed to be present in the content while still considering it to be a match.\n *\n * @param {string} search User input search string\n * @param {string} content Content to search over for matches\n * @param {number} minCharacters Minimum number of search characters before matching anything, default 3\n * @param {number} maxGaps Approximate maximum number of gaps in the search string to tune fuzzyness, default 2\n * @returns {boolean} If a match is found\n */\nconst fuzzySearch = (search: string, content: ?string, minCharacters: number = 3, maxGaps: number = 2): boolean => {\n    if (!content) {\n        return false;\n    }\n    const uniformContent = content.toLowerCase().replace(/\\s/g, '');\n    const uniformSearch = search.toLowerCase().replace(/\\s/g, '');\n    const contentLength = uniformContent.length;\n    const searchLength = uniformSearch.length;\n    if (searchLength < minCharacters || searchLength > contentLength) {\n        return false;\n    }\n    let matched = false;\n    let totalScore = 0;\n    for (let i = 0; i < contentLength; i += 1) {\n        if (contentLength - i < searchLength) {\n            break;\n        }\n        let searchIndex = 0;\n        let currentScore = 0;\n        let subScore = 0;\n        for (let j = i; j < contentLength; j += 1) {\n            if (uniformContent[j] === uniformSearch[searchIndex]) {\n                searchIndex += 1;\n                // For streaks of matched characters score should increase exponentially\n                currentScore += 1 + currentScore;\n            } else {\n                currentScore = 0;\n            }\n            subScore += currentScore;\n        }\n        if (searchIndex !== searchLength) {\n            break;\n        }\n        if (subScore > totalScore) {\n            totalScore = subScore;\n        }\n    }\n    if (totalScore > 0) {\n        const maxGroups = Math.min(maxGaps, searchLength);\n        // minScore is calculated as a near-worst-case score given an even distribution of gaps\n        // since the algorithm rewards streak of characters breaking them up evenly is the worst case\n        // minimum score should also be better than just each character individually\n        const minScore = Math.max(maxGroups * 2 ** Math.floor(searchLength / maxGroups - 1), searchLength + 1);\n        matched = totalScore >= minScore;\n    }\n    return matched;\n};\n\nexport default fuzzySearch;\n"],"file":"fuzzySearch.js"}