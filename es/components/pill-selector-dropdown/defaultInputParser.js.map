{"version":3,"sources":["../../../src/components/pill-selector-dropdown/defaultInputParser.js"],"names":["uniqBy","escapeRegExp","parseCSV","defaultInputParser","inputValue","options","selectedOptions","mappedOptions","inputTokens","map","inputToken","trimmedInputToken","replace","escapedInputToken","regex","RegExp","existingOption","find","displayText","value","test","String","mappedOption","filter","some","selectedOption"],"mappings":"AACA,OAAOA,MAAP,MAAmB,eAAnB;AACA,OAAOC,YAAP,MAAyB,qBAAzB;AAEA,OAAOC,QAAP,MAAqB,sBAArB;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,kBAAT,CAA4BC,UAA5B,EAAgDC,OAAhD,EAAwEC,eAAxE,EAAuH;AACnH,MAAIC,aAAJ;AACA,MAAMC,WAAW,GAAGN,QAAQ,CAACE,UAAD,CAA5B;AAEAG,EAAAA,aAAa,GAAGC,WAAW,CAACC,GAAZ,CAAgB,UAACC,UAAD,EAAgC;AAC5D,QAAMC,iBAAiB,GAAGD,UAAU,CAACE,OAAX,CAAmB,KAAnB,EAA0B,EAA1B,CAA1B;AACA,QAAMC,iBAAiB,GAAGZ,YAAY,CAACU,iBAAD,CAAtC;AACA,QAAMG,KAAK,GAAG,IAAIC,MAAJ,YAAeF,iBAAf,QAAqC,GAArC,CAAd;AAEA,QAAMG,cAAc,GAAGX,OAAO,CAACY,IAAR,CACnB;AAAA,UAAGC,WAAH,QAAGA,WAAH;AAAA,UAAgBC,KAAhB,QAAgBA,KAAhB;AAAA,aACI;AACAL,QAAAA,KAAK,CAACM,IAAN,CAAWF,WAAW,CAACN,OAAZ,CAAoB,OAApB,EAA6B,EAA7B,CAAX,KAAgDE,KAAK,CAACM,IAAN,CAAWC,MAAM,CAACF,KAAD,CAAjB;AAFpD;AAAA,KADmB,CAAvB;AAKA,QAAMG,YAAY,GAAGN,cAAc,IAAI;AACnCE,MAAAA,WAAW,EAAER,UADsB;AAEnCS,MAAAA,KAAK,EAAET;AAF4B,KAAvC;AAIA,WAAOY,YAAP;AACH,GAfe,CAAhB,CAJmH,CAoBnH;;AACAf,EAAAA,aAAa,GAAGP,MAAM,CAACO,aAAD,EAAgB,UAAAe,YAAY;AAAA,WAAIA,YAAY,CAACH,KAAjB;AAAA,GAA5B,CAAtB,CArBmH,CAsBnH;;AACAZ,EAAAA,aAAa,GAAGA,aAAa,CAACgB,MAAd,CACZ,UAAAD,YAAY;AAAA,WAAI,CAAChB,eAAe,CAACkB,IAAhB,CAAqB,UAAAC,cAAc;AAAA,aAAIH,YAAY,CAACH,KAAb,KAAuBM,cAAc,CAACN,KAA1C;AAAA,KAAnC,CAAL;AAAA,GADA,CAAhB;AAGA,SAAOZ,aAAP;AACH;;AAED,eAAeJ,kBAAf","sourcesContent":["// @flow\nimport uniqBy from 'lodash/uniqBy';\nimport escapeRegExp from 'lodash/escapeRegExp';\n\nimport parseCSV from '../../utils/parseCSV';\n\nimport type { Option } from './flowTypes';\n\n// Custom input parser for the PillSelectorDropdownField that automatically maps\n// a list of comma separated values to their respective Option objects. The parser\n// will try to find exact but case-insenstive matches using the option's displayText\n// property. If a token does not match displayText, the parser will also try to match\n// the string representation of the value property. This last match is useful for country\n// codes and other similar use cases.\nfunction defaultInputParser(inputValue: string, options: Array<Option>, selectedOptions: Array<Option>): Array<Option> {\n    let mappedOptions;\n    const inputTokens = parseCSV(inputValue);\n\n    mappedOptions = inputTokens.map((inputToken: string): Option => {\n        const trimmedInputToken = inputToken.replace(/\\s/g, '');\n        const escapedInputToken = escapeRegExp(trimmedInputToken);\n        const regex = new RegExp(`^${escapedInputToken}$`, 'i');\n\n        const existingOption = options.find(\n            ({ displayText, value }: Option) =>\n                // Match name without whitespace or commas\n                regex.test(displayText.replace(/\\s|,/g, '')) || regex.test(String(value)),\n        );\n        const mappedOption = existingOption || {\n            displayText: inputToken,\n            value: inputToken,\n        };\n        return mappedOption;\n    });\n    // Remove duplicate values\n    mappedOptions = uniqBy(mappedOptions, mappedOption => mappedOption.value);\n    // Remove previously selected values\n    mappedOptions = mappedOptions.filter(\n        mappedOption => !selectedOptions.some(selectedOption => mappedOption.value === selectedOption.value),\n    );\n    return mappedOptions;\n}\n\nexport default defaultInputParser;\n"],"file":"defaultInputParser.js"}