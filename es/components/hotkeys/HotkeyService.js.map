{"version":3,"sources":["../../../src/components/hotkeys/HotkeyService.js"],"names":["OrderedMap","OrderedSet","Mousetrap","uniqueId","HotkeyManager","HotkeyService","mousetrap","addEventListener","type","callback","mousetrapEventHandler","event","getActiveLayerID","layerID","stopPropagation","reset","setActiveLayer","window","removeLayer","removeEventListener","hotkeys","toOrderedSet","reduce","hotkey","push","types","add","toJS","hotkeyConfig","key","handler","keys","Array","isArray","badKeys","filter","candidate","has","existingConfig","get","length","Error","bind","forEach","keyBinding","set","delete","unbind"],"mappings":"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","sourcesContent":["import { OrderedMap, OrderedSet } from 'immutable';\nimport Mousetrap from 'mousetrap';\nimport uniqueId from 'lodash/uniqueId';\n\nimport HotkeyManager from './HotkeyManager';\n\n// An instance of this class represents one hotkey \"layer\"\nclass HotkeyService {\n    constructor() {\n        // create a fake HTML element to grab the event listener from mousetrap.\n        // hacky, but mousetrap unfortunately doesn't expose this handler :(\n        this.mousetrap = new Mousetrap({\n            addEventListener: (type, callback) => {\n                this.mousetrapEventHandler = event => {\n                    if (HotkeyManager.getActiveLayerID() !== this.layerID) {\n                        return;\n                    }\n                    // event should not propagate past this layer, no matter what\n                    event.stopPropagation();\n                    callback(event);\n                };\n            },\n        });\n        this.reset();\n\n        this.layerID = uniqueId('hotkey-layer');\n        HotkeyManager.setActiveLayer(this.layerID);\n\n        window.addEventListener('keypress', this.mousetrapEventHandler);\n        window.addEventListener('keydown', this.mousetrapEventHandler);\n        window.addEventListener('keyup', this.mousetrapEventHandler);\n    }\n\n    destroyLayer() {\n        HotkeyManager.removeLayer(this.layerID);\n        window.removeEventListener('keypress', this.mousetrapEventHandler);\n        window.removeEventListener('keydown', this.mousetrapEventHandler);\n        window.removeEventListener('keyup', this.mousetrapEventHandler);\n    }\n\n    reset() {\n        // Use an ordered collection since we ultimately display keys in the order they were added\n        this.hotkeys = new OrderedMap();\n        this.mousetrap.reset();\n    }\n\n    getActiveHotkeys() {\n        // Sort hotkeys into buckets by \"type\"\n        return this.hotkeys.toOrderedSet().reduce((hotkeys, hotkey) => {\n            const { type } = hotkey;\n            if (!type) {\n                return hotkeys;\n            }\n            if (!(type in hotkeys)) {\n                hotkeys[type] = [];\n            }\n            hotkeys[type].push(hotkey);\n            return hotkeys;\n        }, {});\n    }\n\n    getActiveTypes() {\n        // Get \"types\" of hotkeys in sorted order, by first hotkey\n        // e.g. if the current layer has:\n        // [\n        //     { key: 'shift+a', type: 'File Selection' },\n        //     { key: 'shift+g+a', type: 'Navigation' },\n        //     { key: 'shift+x', type: 'File Selection' },\n        // ]\n        // then this function would output [ 'File Selection', 'Navigation' ].\n        // Used to help generate the hotkey help modal menu options.\n        return this.hotkeys.reduce((types, { type }) => (type ? types.add(type) : types), new OrderedSet()).toJS();\n    }\n\n    registerHotkey(hotkeyConfig) {\n        const { key, handler } = hotkeyConfig;\n        const keys = Array.isArray(key) ? key : [key];\n        const badKeys = keys.filter(candidate => this.hotkeys.has(candidate));\n        const existingConfig = this.hotkeys.get(keys[0]);\n\n        // Ignore the whole config if it has already been registered\n        if (existingConfig === hotkeyConfig) {\n            return;\n        }\n\n        // If any of the keys are being used by another config, abort rudely.\n        if (badKeys.length !== 0) {\n            throw new Error(`This app is trying to bind multiple actions to the hot keys: ${badKeys}.`);\n        }\n\n        this.mousetrap.bind(keys, handler);\n        keys.forEach(keyBinding => {\n            this.hotkeys = this.hotkeys.set(keyBinding, hotkeyConfig);\n        });\n    }\n\n    deregisterHotkey(hotkeyConfig) {\n        const { key } = hotkeyConfig;\n        const keys = Array.isArray(key) ? key : [key];\n\n        keys.forEach(keyBinding => {\n            this.hotkeys = this.hotkeys.delete(keyBinding);\n        });\n        this.mousetrap.unbind(keys);\n    }\n}\n\nexport default HotkeyService;\n"],"file":"HotkeyService.js"}