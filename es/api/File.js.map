{"version":3,"sources":["../../src/api/File.js"],"names":["queryString","getProp","findMissingProperties","fillMissingProperties","getTypedFileId","getBadItemError","getBadPermissionsError","CACHE_PREFIX_FILE","ERROR_CODE_FETCH_FILE","ERROR_CODE_GET_DOWNLOAD_URL","FIELD_AUTHENTICATED_DOWNLOAD_URL","FIELD_EXTENSION","FIELD_IS_DOWNLOAD_AVAILABLE","X_REP_HINTS","Item","TokenService","File","id","suffix","getBaseApiUrl","fileId","fileOrFileVersion","successCallback","errorCallback","errorCode","downloadAvailable","downloadUrl","getReadToken","options","token","errorHandler","Error","parseUrl","query","downloadBaseUrl","url","downloadUrlParams","access_token","downloadUrlQuery","stringify","successHandler","item","entry","extension","template","thumbnailUrl","replace","thumbnailBaseUrl","thumbnailUrlParams","thumbnailUrlQuery","file","description","permissions","Promise","reject","can_rename","xhr","put","getUrl","data","then","isDestroyed","updatedFile","merge","getCacheKey","catch","originalFile","cache","getCache","key","isCached","forceFetch","has","get","missingFields","fields","xhrOptions","headers","length","refreshCache","params","toString","dataWithMissingFields","set","getFile"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AAEA,OAAOA,WAAP,MAAwB,cAAxB;AACA,OAAOC,OAAP,MAAoB,YAApB;AACA,SAASC,qBAAT,EAAgCC,qBAAhC,QAA6D,iBAA7D;AACA,SAASC,cAAT,QAA+B,eAA/B;AACA,SAASC,eAAT,EAA0BC,sBAA1B,QAAwD,gBAAxD;AACA,SACIC,iBADJ,EAEIC,qBAFJ,EAGIC,2BAHJ,EAIIC,gCAJJ,EAKIC,eALJ,EAMIC,2BANJ,EAOIC,WAPJ,QAQO,cARP;AASA,OAAOC,IAAP,MAAiB,QAAjB;AACA,OAAOC,YAAP,MAAyB,uBAAzB;;IAEMC,I;;;;;;;;;;;;;;AACF;AACJ;AACA;AACA;AACA;AACA;gCACgBC,E,EAAoB;AAC5B,uBAAUV,iBAAV,SAA8BU,EAA9B;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;;;2BACWA,E,EAAoB;AACvB,UAAMC,MAAc,GAAGD,EAAE,cAAOA,EAAP,IAAc,EAAvC;AACA,uBAAU,KAAKE,aAAL,EAAV,mBAAuCD,MAAvC;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;qGAEQE,M,EACAC,iB,EACAC,e,EACAC,a;;;;;;;AAEA,qBAAKC,SAAL,GAAiBf,2BAAjB;AACA,qBAAKc,aAAL,GAAqBA,aAArB;AACA,qBAAKD,eAAL,GAAuBA,eAAvB;AAEMG,gBAAAA,iB,GAAoBJ,iBAAiB,CAACT,2BAAD,C;AACrCc,gBAAAA,W,GAAcL,iBAAiB,CAACX,gCAAD,C;;uBACjBK,YAAY,CAACY,YAAb,CAA0BvB,cAAc,CAACgB,MAAD,CAAxC,EAAkD,KAAKQ,OAAL,CAAaC,KAA/D,C;;;AAAdA,gBAAAA,K;;sBAEF,CAACJ,iBAAD,IAAsB,CAACC,WAAvB,IAAsC,CAACG,K;;;;;AACvC,qBAAKC,YAAL,CAAkB,IAAIC,KAAJ,CAAU,+CAAV,CAAlB;;;;wCAIoC/B,WAAW,CAACgC,QAAZ,CAAqBN,WAArB,C,EAAhCO,K,yBAAAA,K,EAAYC,e,yBAALC,G;AACTC,gBAAAA,iB,mCAAyBH,K;AAAOI,kBAAAA,YAAY,EAAER;;AAC9CS,gBAAAA,gB,GAAmBtC,WAAW,CAACuC,SAAZ,CAAsBH,iBAAtB,C;AAEzB,qBAAKI,cAAL,WAAuBN,eAAvB,cAA0CI,gBAA1C;;;;;;;;;;;;;;;;AAGJ;AACJ;AACA;AACA;AACA;AACA;;;;;uGAC0BG,I;;;;;;;AACZC,gBAAAA,K,GAAQzC,OAAO,CAACwC,IAAD,EAAO,4BAAP,C;AACfE,gBAAAA,S,GAAY1C,OAAO,CAACyC,KAAD,EAAQ,gBAAR,C;AACnBE,gBAAAA,Q,GAAW3C,OAAO,CAACyC,KAAD,EAAQ,sBAAR,C;;uBACJ3B,YAAY,CAACY,YAAb,CAA0BvB,cAAc,CAACqC,IAAI,CAACxB,EAAN,CAAxC,EAAmD,KAAKW,OAAL,CAAaC,KAAhE,C;;;AAAdA,gBAAAA,K;;sBAEF5B,OAAO,CAACyC,KAAD,EAAQ,cAAR,CAAP,KAAmC,SAAnC,IAAgD,CAACC,SAAjD,IAA8D,CAACC,QAA/D,IAA2E,CAACf,K;;;;;kDACrE,I;;;AAGLgB,gBAAAA,Y,GAAeD,QAAQ,CAACE,OAAT,CAAiB,eAAjB,EAAkCH,SAAS,KAAK,KAAd,GAAsB,EAAtB,GAA2B,OAA7D,C;yCAEoB3C,WAAW,CAACgC,QAAZ,CAAqBa,YAArB,C,EAAjCZ,K,0BAAAA,K,EAAYc,gB,0BAALZ,G;AACTa,gBAAAA,kB,mCAA0Bf,K;AAAOI,kBAAAA,YAAY,EAAER;;AAC/CoB,gBAAAA,iB,GAAoBjD,WAAW,CAACuC,SAAZ,CAAsBS,kBAAtB,C;4DAEhBD,gB,cAAoBE,iB;;;;;;;;;;;;;;;;AAGlC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;uCAEQC,I,EACAC,W,EACA7B,e,EACAC,a,EACa;AAAA;;AAAA,UACLN,EADK,GACeiC,IADf,CACLjC,EADK;AAAA,UACDmC,WADC,GACeF,IADf,CACDE,WADC;;AAGb,UAAI,CAACnC,EAAD,IAAO,CAACmC,WAAZ,EAAyB;AACrB7B,QAAAA,aAAa,CAAClB,eAAe,EAAhB,CAAb;AACA,eAAOgD,OAAO,CAACC,MAAR,EAAP;AACH;;AAED,UAAI,CAACF,WAAW,CAACG,UAAjB,EAA6B;AACzBhC,QAAAA,aAAa,CAACjB,sBAAsB,EAAvB,CAAb;AACA,eAAO+C,OAAO,CAACC,MAAR,EAAP;AACH;;AAED,aAAO,KAAKE,GAAL,CACFC,GADE,CACE;AACDxC,QAAAA,EAAE,EAAEb,cAAc,CAACa,EAAD,CADjB;AAEDkB,QAAAA,GAAG,EAAE,KAAKuB,MAAL,CAAYzC,EAAZ,CAFJ;AAGD0C,QAAAA,IAAI,EAAE;AAAER,UAAAA,WAAW,EAAXA;AAAF;AAHL,OADF,EAMFS,IANE,CAMG,gBAAiC;AAAA,YAA9BD,IAA8B,QAA9BA,IAA8B;;AACnC,YAAI,CAAC,KAAI,CAACE,WAAL,EAAL,EAAyB;AACrB,cAAMC,WAAW,GAAG,KAAI,CAACC,KAAL,CAAW,KAAI,CAACC,WAAL,CAAiB/C,EAAjB,CAAX,EAAiC,aAAjC,EAAgD0C,IAAI,CAACR,WAArD,CAApB;;AACA7B,UAAAA,eAAe,CAACwC,WAAD,CAAf;AACH;AACJ,OAXE,EAYFG,KAZE,CAYI,YAAM;AACT,YAAI,CAAC,KAAI,CAACJ,WAAL,EAAL,EAAyB;AACrB,cAAMK,YAAY,GAAG,KAAI,CAACH,KAAL,CAAW,KAAI,CAACC,WAAL,CAAiB/C,EAAjB,CAAX,EAAiC,aAAjC,EAAgDiC,IAAI,CAACC,WAArD,CAArB;;AACA5B,UAAAA,aAAa,CAAC2C,YAAD,CAAb;AACH;AACJ,OAjBE,CAAP;AAkBH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;+FAEQjD,E,EACAK,e,EACAC,a;;;;;;;;;;;;;;;;;AACAK,gBAAAA,O,8DAAwB,E;;qBAEpB,KAAKiC,WAAL,E;;;;;;;;AAIEM,gBAAAA,K,GAAkB,KAAKC,QAAL,E;AAClBC,gBAAAA,G,GAAc,KAAKL,WAAL,CAAiB/C,EAAjB,C;AACdqD,gBAAAA,Q,GAAoB,CAAC1C,OAAO,CAAC2C,UAAT,IAAuBJ,KAAK,CAACK,GAAN,CAAUH,GAAV,C;AAC3CnB,gBAAAA,I,GAAgBoB,QAAQ,GAAGH,KAAK,CAACM,GAAN,CAAUJ,GAAV,CAAH,GAAoB;AAAEpD,kBAAAA,EAAE,EAAFA;AAAF,iB;AAC9CyD,gBAAAA,a,GAA+BxE,qBAAqB,CAACgD,IAAD,EAAOtB,OAAO,CAAC+C,MAAf,C;AAClDC,gBAAAA,U,GAAqB;AACvB3D,kBAAAA,EAAE,EAAEb,cAAc,CAACa,EAAD,CADK;AAEvBkB,kBAAAA,GAAG,EAAE,KAAKuB,MAAL,CAAYzC,EAAZ,CAFkB;AAGvB4D,kBAAAA,OAAO,EAAE;AAAE,mCAAehE;AAAjB;AAHc,iB;AAK3B,qBAAKW,SAAL,GAAiBhB,qBAAjB;AACA,qBAAKc,eAAL,GAAuBA,eAAvB;AACA,qBAAKC,aAAL,GAAqBA,aAArB,C,CAEA;AACA;AACA;;sBACI+C,QAAQ,IAAII,aAAa,CAACI,MAAd,KAAyB,C;;;;;AACrCxD,gBAAAA,eAAe,CAAC4B,IAAD,CAAf;AACAwB,gBAAAA,aAAa,GAAG9C,OAAO,CAAC+C,MAAR,IAAkB,EAAlC;;oBACK/C,OAAO,CAACmD,Y;;;;;;;;AAKjB;AACA,oBAAIL,aAAa,CAACI,MAAd,GAAuB,CAA3B,EAA8B;AAC1BF,kBAAAA,UAAU,CAACI,MAAX,GAAoB;AAChBL,oBAAAA,MAAM,EAAED,aAAa,CAACO,QAAd;AADQ,mBAApB;AAGH;;;;uBAG0B,KAAKzB,GAAL,CAASiB,GAAT,CAAaG,UAAb,C;;;;AAAfjB,gBAAAA,I,uBAAAA,I;;qBACJ,KAAKE,WAAL,E;;;;;;;;AAIJ;AACA;AACA;AACMqB,gBAAAA,qB,GAAwB/E,qBAAqB,CAACwD,IAAD,EAAOe,aAAP,C,EAEnD;;AACA,oBAAIP,KAAK,CAACK,GAAN,CAAUH,GAAV,CAAJ,EAAoB;AAChBF,kBAAAA,KAAK,CAACJ,KAAN,CAAYM,GAAZ,EAAiBa,qBAAjB;AACH,iBAFD,MAEO;AACH;AACAf,kBAAAA,KAAK,CAACgB,GAAN,CAAUd,GAAV,EAAea,qBAAf;AACH;;AAED,qBAAK1C,cAAL,CAAoB2B,KAAK,CAACM,GAAN,CAAUJ,GAAV,CAApB;;;;;;;AAEA,qBAAKvC,YAAL;;;;;;;;;;;;;;;;AAIR;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;;qCACqBb,E,EAAYK,e,EAA2BC,a,EAA4C;AAChG,UAAI,KAAKsC,WAAL,EAAJ,EAAwB;AACpB;AACH;;AAED,WAAKuB,OAAL,CAAanE,EAAb,EAAiBK,eAAjB,EAAkCC,aAAlC,EAAiD;AAC7CoD,QAAAA,MAAM,EAAE,CAAChE,eAAD;AADqC,OAAjD;AAGH;;;;EA/NcG,I;;AAkOnB,eAAeE,IAAf","sourcesContent":["/**\n * @flow\n * @file Helper for the box file API\n * @author Box\n */\n\nimport queryString from 'query-string';\nimport getProp from 'lodash/get';\nimport { findMissingProperties, fillMissingProperties } from '../utils/fields';\nimport { getTypedFileId } from '../utils/file';\nimport { getBadItemError, getBadPermissionsError } from '../utils/error';\nimport {\n    CACHE_PREFIX_FILE,\n    ERROR_CODE_FETCH_FILE,\n    ERROR_CODE_GET_DOWNLOAD_URL,\n    FIELD_AUTHENTICATED_DOWNLOAD_URL,\n    FIELD_EXTENSION,\n    FIELD_IS_DOWNLOAD_AVAILABLE,\n    X_REP_HINTS,\n} from '../constants';\nimport Item from './Item';\nimport TokenService from '../utils/TokenService';\n\nclass File extends Item {\n    /**\n     * Creates a key for the cache\n     *\n     * @param {string} id - Folder id\n     * @return {string} key\n     */\n    getCacheKey(id: string): string {\n        return `${CACHE_PREFIX_FILE}${id}`;\n    }\n\n    /**\n     * API URL for files\n     *\n     * @param {string} [id] - Optional file id\n     * @return {string} base url for files\n     */\n    getUrl(id: string): string {\n        const suffix: string = id ? `/${id}` : '';\n        return `${this.getBaseApiUrl()}/files${suffix}`;\n    }\n\n    /**\n     * API for getting download URL for files and file versions\n     *\n     * @param {string} fileId - File id\n     * @param {BoxItem|BoxItemVersion} fileOrFileVersion - File or file version to download\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {void}\n     */\n    async getDownloadUrl(\n        fileId: string,\n        fileOrFileVersion: BoxItem | BoxItemVersion,\n        successCallback: string => void,\n        errorCallback: ElementsErrorCallback,\n    ): Promise<void> {\n        this.errorCode = ERROR_CODE_GET_DOWNLOAD_URL;\n        this.errorCallback = errorCallback;\n        this.successCallback = successCallback;\n\n        const downloadAvailable = fileOrFileVersion[FIELD_IS_DOWNLOAD_AVAILABLE];\n        const downloadUrl = fileOrFileVersion[FIELD_AUTHENTICATED_DOWNLOAD_URL];\n        const token = await TokenService.getReadToken(getTypedFileId(fileId), this.options.token);\n\n        if (!downloadAvailable || !downloadUrl || !token) {\n            this.errorHandler(new Error('Download is missing required fields or token.'));\n            return;\n        }\n\n        const { query, url: downloadBaseUrl } = queryString.parseUrl(downloadUrl);\n        const downloadUrlParams = { ...query, access_token: token };\n        const downloadUrlQuery = queryString.stringify(downloadUrlParams);\n\n        this.successHandler(`${downloadBaseUrl}?${downloadUrlQuery}`);\n    }\n\n    /**\n     * API for getting a thumbnail URL for a BoxItem\n     *\n     * @param {BoxItem} item - BoxItem to get the thumbnail URL for\n     * @return {Promise<?string>} - the url for the item's thumbnail, or null\n     */\n    async getThumbnailUrl(item: BoxItem): Promise<?string> {\n        const entry = getProp(item, 'representations.entries[0]');\n        const extension = getProp(entry, 'representation');\n        const template = getProp(entry, 'content.url_template');\n        const token = await TokenService.getReadToken(getTypedFileId(item.id), this.options.token);\n\n        if (getProp(entry, 'status.state') !== 'success' || !extension || !template || !token) {\n            return null;\n        }\n\n        const thumbnailUrl = template.replace('{+asset_path}', extension === 'jpg' ? '' : '1.png');\n\n        const { query, url: thumbnailBaseUrl } = queryString.parseUrl(thumbnailUrl);\n        const thumbnailUrlParams = { ...query, access_token: token };\n        const thumbnailUrlQuery = queryString.stringify(thumbnailUrlParams);\n\n        return `${thumbnailBaseUrl}?${thumbnailUrlQuery}`;\n    }\n\n    /**\n     * API for setting the description of a file\n     *\n     * @param {BoxItem} file - File object for which we are changing the description\n     * @param {string} description - New file description\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {Promise}\n     */\n    setFileDescription(\n        file: BoxItem,\n        description: string,\n        successCallback: Function,\n        errorCallback: Function,\n    ): Promise<void> {\n        const { id, permissions } = file;\n\n        if (!id || !permissions) {\n            errorCallback(getBadItemError());\n            return Promise.reject();\n        }\n\n        if (!permissions.can_rename) {\n            errorCallback(getBadPermissionsError());\n            return Promise.reject();\n        }\n\n        return this.xhr\n            .put({\n                id: getTypedFileId(id),\n                url: this.getUrl(id),\n                data: { description },\n            })\n            .then(({ data }: { data: BoxItem }) => {\n                if (!this.isDestroyed()) {\n                    const updatedFile = this.merge(this.getCacheKey(id), 'description', data.description);\n                    successCallback(updatedFile);\n                }\n            })\n            .catch(() => {\n                if (!this.isDestroyed()) {\n                    const originalFile = this.merge(this.getCacheKey(id), 'description', file.description);\n                    errorCallback(originalFile);\n                }\n            });\n    }\n\n    /**\n     * Gets a box file\n     *\n     * @param {string} id - File id\n     * @param {Function} successCallback - Function to call with results\n     * @param {Function} errorCallback - Function to call with errors\n     * @param {boolean|void} [options.fields] - Optionally include specific fields\n     * @param {boolean|void} [options.forceFetch] - Optionally Bypasses the cache\n     * @param {boolean|void} [options.refreshCache] - Optionally Updates the cache\n     * @return {Promise}\n     */\n    async getFile(\n        id: string,\n        successCallback: Function,\n        errorCallback: ElementsErrorCallback,\n        options: FetchOptions = {},\n    ): Promise<void> {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        const cache: APICache = this.getCache();\n        const key: string = this.getCacheKey(id);\n        const isCached: boolean = !options.forceFetch && cache.has(key);\n        const file: BoxItem = isCached ? cache.get(key) : { id };\n        let missingFields: Array<string> = findMissingProperties(file, options.fields);\n        const xhrOptions: Object = {\n            id: getTypedFileId(id),\n            url: this.getUrl(id),\n            headers: { 'X-Rep-Hints': X_REP_HINTS },\n        };\n        this.errorCode = ERROR_CODE_FETCH_FILE;\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n\n        // If the file was cached and there are no missing fields\n        // then just return the cached file and optionally refresh\n        // the cache with new data if required\n        if (isCached && missingFields.length === 0) {\n            successCallback(file);\n            missingFields = options.fields || [];\n            if (!options.refreshCache) {\n                return;\n            }\n        }\n\n        // If there are missing fields to fetch, add it to the params\n        if (missingFields.length > 0) {\n            xhrOptions.params = {\n                fields: missingFields.toString(),\n            };\n        }\n\n        try {\n            const { data } = await this.xhr.get(xhrOptions);\n            if (this.isDestroyed()) {\n                return;\n            }\n\n            // Merge fields that were requested but were actually not returned.\n            // This part is mostly useful for metadata.foo.bar fields since the API\n            // returns { metadata: null } instead of { metadata: { foo: { bar: null } } }\n            const dataWithMissingFields = fillMissingProperties(data, missingFields);\n\n            // Cache check is again done since this code is executed async\n            if (cache.has(key)) {\n                cache.merge(key, dataWithMissingFields);\n            } else {\n                // If there was nothing in the cache\n                cache.set(key, dataWithMissingFields);\n            }\n\n            this.successHandler(cache.get(key));\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n\n    /**\n     * Gets the extension of a box file.\n     *\n     * @param {string} id - File id\n     * @param {Function} successCallback - Function to call with results\n     * @param {Function} errorCallback - Function to call with errors\n     * @return {Promise}\n     */\n    getFileExtension(id: string, successCallback: Function, errorCallback: ElementsErrorCallback): void {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        this.getFile(id, successCallback, errorCallback, {\n            fields: [FIELD_EXTENSION],\n        });\n    }\n}\n\nexport default File;\n"],"file":"File.js"}