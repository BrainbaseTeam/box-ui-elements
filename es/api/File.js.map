{"version":3,"sources":["../../src/api/File.js"],"names":["queryString","getProp","findMissingProperties","fillMissingProperties","getTypedFileId","getBadItemError","getBadPermissionsError","CACHE_PREFIX_FILE","ERROR_CODE_FETCH_FILE","ERROR_CODE_GET_DOWNLOAD_URL","FIELD_AUTHENTICATED_DOWNLOAD_URL","FIELD_EXTENSION","FIELD_IS_DOWNLOAD_AVAILABLE","REPRESENTATIONS_RESPONSE_ERROR","REPRESENTATIONS_RESPONSE_SUCCESS","REPRESENTATIONS_RESPONSE_VIEWABLE","X_REP_HINTS","Item","retryNumOfTimes","TokenService","File","id","suffix","getBaseApiUrl","fileId","fileOrFileVersion","successCallback","errorCallback","errorCode","downloadAvailable","downloadUrl","getReadToken","options","token","errorHandler","Error","parseUrl","query","downloadBaseUrl","url","downloadUrlParams","access_token","downloadUrlQuery","stringify","successHandler","response","status","representation","infoUrl","xhr","get","then","isRepresentationsCallComplete","data","catch","e","item","entry","extension","template","thumbnailUrl","replace","thumbnailBaseUrl","thumbnailUrlParams","thumbnailUrlQuery","file","description","permissions","Promise","reject","can_rename","put","getUrl","isDestroyed","updatedFile","merge","getCacheKey","originalFile","cache","getCache","key","isCached","forceFetch","has","missingFields","fields","xhrOptions","headers","length","refreshCache","params","toString","dataWithMissingFields","set","getFile"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;AAMA,OAAOA,WAAP,MAAwB,cAAxB;AACA,OAAOC,OAAP,MAAoB,YAApB;AACA,SAASC,qBAAT,EAAgCC,qBAAhC,QAA6D,iBAA7D;AACA,SAASC,cAAT,QAA+B,eAA/B;AACA,SAASC,eAAT,EAA0BC,sBAA1B,QAAwD,gBAAxD;AACA,SACIC,iBADJ,EAEIC,qBAFJ,EAGIC,2BAHJ,EAIIC,gCAJJ,EAKIC,eALJ,EAMIC,2BANJ,EAOIC,8BAPJ,EAQIC,gCARJ,EASIC,iCATJ,EAUIC,WAVJ,QAWO,cAXP;AAYA,OAAOC,IAAP,MAAiB,QAAjB;AACA,SAASC,eAAT,QAAgC,mBAAhC;AACA,OAAOC,YAAP,MAAyB,uBAAzB;;IAKMC,I;;;;;;;;;;;;;;AACF;;;;;;gCAMYC,E,EAAoB;AAC5B,uBAAUd,iBAAV,SAA8Bc,EAA9B;AACH;AAED;;;;;;;;;2BAMOA,E,EAAoB;AACvB,UAAMC,MAAc,GAAGD,EAAE,cAAOA,EAAP,IAAc,EAAvC;AACA,uBAAU,KAAKE,aAAL,EAAV,mBAAuCD,MAAvC;AACH;AAED;;;;;;;;;;;;;;;+CAUIE,M,EACAC,iB,EACAC,e,EACAC,a;;;;;;;AAEA,qBAAKC,SAAL,GAAiBnB,2BAAjB;AACA,qBAAKkB,aAAL,GAAqBA,aAArB;AACA,qBAAKD,eAAL,GAAuBA,eAAvB;AAEMG,gBAAAA,iB,GAAoBJ,iBAAiB,CAACb,2BAAD,C;AACrCkB,gBAAAA,W,GAAcL,iBAAiB,CAACf,gCAAD,C;;uBACjBS,YAAY,CAACY,YAAb,CAA0B3B,cAAc,CAACoB,MAAD,CAAxC,EAAkD,KAAKQ,OAAL,CAAaC,KAA/D,C;;;AAAdA,gBAAAA,K;;sBAEF,CAACJ,iBAAD,IAAsB,CAACC,WAAvB,IAAsC,CAACG,K;;;;;AACvC,qBAAKC,YAAL,CAAkB,IAAIC,KAAJ,CAAU,+CAAV,CAAlB;;;;wCAIoCnC,WAAW,CAACoC,QAAZ,CAAqBN,WAArB,C,EAAhCO,K,yBAAAA,K,EAAYC,e,yBAALC,G;AACTC,gBAAAA,iB,qBAAyBH,K;AAAOI,kBAAAA,YAAY,EAAER;;AAC9CS,gBAAAA,gB,GAAmB1C,WAAW,CAAC2C,SAAZ,CAAsBH,iBAAtB,C;AAEzB,qBAAKI,cAAL,WAAuBN,eAAvB,cAA0CI,gBAA1C;;;;;;;;;;;;;;;;AAGJ;;;;;;;;;kDAM8BG,Q,EAAiD;AAC3E,UAAMC,MAAM,GAAG7C,OAAO,CAAC4C,QAAD,EAAW,mBAAX,CAAtB;AACA,aACI,CAACC,MAAD,IACAA,MAAM,KAAKjC,8BADX,IAEAiC,MAAM,KAAKhC,gCAFX,IAGAgC,MAAM,KAAK/B,iCAJf;AAMH;AAED;;;;;;;;;;;;gDAM6BgC,c;;;;;;;;AACnBC,gBAAAA,O,GAAU/C,OAAO,CAAC8C,cAAD,EAAiB,UAAjB,C;;oBAElBC,O;;;;;kDACMD,c;;;kDAGJ7B,eAAe,CAClB,UAACQ,eAAD,EAAkBC,aAAlB;AAAA,yBACI,KAAI,CAACsB,GAAL,CACKC,GADL,CACS;AAAExB,oBAAAA,eAAe,EAAfA,eAAF;AAAmBC,oBAAAA,aAAa,EAAbA,aAAnB;AAAkCY,oBAAAA,GAAG,EAAES;AAAvC,mBADT,EAEKG,IAFL,CAEU,UAAAN,QAAQ;AAAA,2BACV,KAAI,CAACO,6BAAL,CAAmCP,QAAnC,IACMnB,eAAe,CAACmB,QAAQ,CAACQ,IAAV,CADrB,GAEM1B,aAAa,CAACkB,QAAQ,CAACQ,IAAV,CAHT;AAAA,mBAFlB,EAOKC,KAPL,CAOW,UAAAC,CAAC,EAAI;AACR5B,oBAAAA,aAAa,CAAC4B,CAAD,CAAb;AACH,mBATL,CADJ;AAAA,iBADkB,EAYlB,CAZkB,EAalB,IAbkB,EAclB,CAdkB,C;;;;;;;;;;;;;;;;AAkB1B;;;;;;;;;;;;gDAMsBC,I;;;;;;;AACZC,gBAAAA,K,GAAQxD,OAAO,CAACuD,IAAD,EAAO,4BAAP,C;AACfE,gBAAAA,S,GAAYzD,OAAO,CAACwD,KAAD,EAAQ,gBAAR,C;AACnBE,gBAAAA,Q,GAAW1D,OAAO,CAACwD,KAAD,EAAQ,sBAAR,C;;uBACJtC,YAAY,CAACY,YAAb,CAA0B3B,cAAc,CAACoD,IAAI,CAACnC,EAAN,CAAxC,EAAmD,KAAKW,OAAL,CAAaC,KAAhE,C;;;AAAdA,gBAAAA,K;;sBAEF,CAACyB,SAAD,IAAc,CAACC,QAAf,IAA2B,CAAC1B,K;;;;;kDACrB,I;;;AAGL2B,gBAAAA,Y,GAAeD,QAAQ,CAACE,OAAT,CAAiB,eAAjB,EAAkCH,SAAS,KAAK,KAAd,GAAsB,EAAtB,GAA2B,OAA7D,C;yCACoB1D,WAAW,CAACoC,QAAZ,CAAqBwB,YAArB,C,EAAjCvB,K,0BAAAA,K,EAAYyB,gB,0BAALvB,G;AACTwB,gBAAAA,kB,qBAA0B1B,K;AAAOI,kBAAAA,YAAY,EAAER;;AAC/C+B,gBAAAA,iB,GAAoBhE,WAAW,CAAC2C,SAAZ,CAAsBoB,kBAAtB,C;4DAChBD,gB,cAAoBE,iB;;;;;;;;;;;;;;;;AAGlC;;;;;;;;;;;;uCAUIC,I,EACAC,W,EACAxC,e,EACAC,a,EACa;AAAA;;AAAA,UACLN,EADK,GACe4C,IADf,CACL5C,EADK;AAAA,UACD8C,WADC,GACeF,IADf,CACDE,WADC;;AAGb,UAAI,CAAC9C,EAAD,IAAO,CAAC8C,WAAZ,EAAyB;AACrBxC,QAAAA,aAAa,CAACtB,eAAe,EAAhB,CAAb;AACA,eAAO+D,OAAO,CAACC,MAAR,EAAP;AACH;;AAED,UAAI,CAACF,WAAW,CAACG,UAAjB,EAA6B;AACzB3C,QAAAA,aAAa,CAACrB,sBAAsB,EAAvB,CAAb;AACA,eAAO8D,OAAO,CAACC,MAAR,EAAP;AACH;;AAED,aAAO,KAAKpB,GAAL,CACFsB,GADE,CACE;AACDlD,QAAAA,EAAE,EAAEjB,cAAc,CAACiB,EAAD,CADjB;AAEDkB,QAAAA,GAAG,EAAE,KAAKiC,MAAL,CAAYnD,EAAZ,CAFJ;AAGDgC,QAAAA,IAAI,EAAE;AAAEa,UAAAA,WAAW,EAAXA;AAAF;AAHL,OADF,EAMFf,IANE,CAMG,gBAAiC;AAAA,YAA9BE,IAA8B,QAA9BA,IAA8B;;AACnC,YAAI,CAAC,MAAI,CAACoB,WAAL,EAAL,EAAyB;AACrB,cAAMC,WAAW,GAAG,MAAI,CAACC,KAAL,CAAW,MAAI,CAACC,WAAL,CAAiBvD,EAAjB,CAAX,EAAiC,aAAjC,EAAgDgC,IAAI,CAACa,WAArD,CAApB;;AACAxC,UAAAA,eAAe,CAACgD,WAAD,CAAf;AACH;AACJ,OAXE,EAYFpB,KAZE,CAYI,YAAM;AACT,YAAI,CAAC,MAAI,CAACmB,WAAL,EAAL,EAAyB;AACrB,cAAMI,YAAY,GAAG,MAAI,CAACF,KAAL,CAAW,MAAI,CAACC,WAAL,CAAiBvD,EAAjB,CAAX,EAAiC,aAAjC,EAAgD4C,IAAI,CAACC,WAArD,CAArB;;AACAvC,UAAAA,aAAa,CAACkD,YAAD,CAAb;AACH;AACJ,OAjBE,CAAP;AAkBH;AAED;;;;;;;;;;;;;;;;;gDAYIxD,E,EACAK,e,EACAC,a;;;;;;;;;;;;;;;;;AACAK,gBAAAA,O,8DAA0B,E;;qBAEtB,KAAKyC,WAAL,E;;;;;;;;AAIEK,gBAAAA,K,GAAkB,KAAKC,QAAL,E;AAClBC,gBAAAA,G,GAAc,KAAKJ,WAAL,CAAiBvD,EAAjB,C;AACd4D,gBAAAA,Q,GAAoB,CAACjD,OAAO,CAACkD,UAAT,IAAuBJ,KAAK,CAACK,GAAN,CAAUH,GAAV,C;AAC3Cf,gBAAAA,I,GAAgBgB,QAAQ,GAAGH,KAAK,CAAC5B,GAAN,CAAU8B,GAAV,CAAH,GAAoB;AAAE3D,kBAAAA,EAAE,EAAFA;AAAF,iB;AAC9C+D,gBAAAA,a,GAA+BlF,qBAAqB,CAAC+D,IAAD,EAAOjC,OAAO,CAACqD,MAAf,C;AAClDC,gBAAAA,U,GAAqB;AACvBjE,kBAAAA,EAAE,EAAEjB,cAAc,CAACiB,EAAD,CADK;AAEvBkB,kBAAAA,GAAG,EAAE,KAAKiC,MAAL,CAAYnD,EAAZ,CAFkB;AAGvBkE,kBAAAA,OAAO,EAAE;AAAE,mCAAevE;AAAjB;AAHc,iB;AAK3B,qBAAKY,SAAL,GAAiBpB,qBAAjB;AACA,qBAAKkB,eAAL,GAAuBA,eAAvB;AACA,qBAAKC,aAAL,GAAqBA,aAArB,C,CAEA;AACA;AACA;;sBACIsD,QAAQ,IAAIG,aAAa,CAACI,MAAd,KAAyB,C;;;;;AACrC9D,gBAAAA,eAAe,CAACuC,IAAD,CAAf;AACAmB,gBAAAA,aAAa,GAAGpD,OAAO,CAACqD,MAAR,IAAkB,EAAlC;;oBACKrD,OAAO,CAACyD,Y;;;;;;;;AAKjB;AACA,oBAAIL,aAAa,CAACI,MAAd,GAAuB,CAA3B,EAA8B;AAC1BF,kBAAAA,UAAU,CAACI,MAAX,GAAoB;AAChBL,oBAAAA,MAAM,EAAED,aAAa,CAACO,QAAd;AADQ,mBAApB;AAGH;;;;uBAG0B,KAAK1C,GAAL,CAASC,GAAT,CAAaoC,UAAb,C;;;;AAAfjC,gBAAAA,I,SAAAA,I;;qBACJ,KAAKoB,WAAL,E;;;;;;;;AAIJ;AACA;AACA;AACMmB,gBAAAA,qB,GAAwBzF,qBAAqB,CAACkD,IAAD,EAAO+B,aAAP,C,EAEnD;;AACA,oBAAIN,KAAK,CAACK,GAAN,CAAUH,GAAV,CAAJ,EAAoB;AAChBF,kBAAAA,KAAK,CAACH,KAAN,CAAYK,GAAZ,EAAiBY,qBAAjB;AACH,iBAFD,MAEO;AACH;AACAd,kBAAAA,KAAK,CAACe,GAAN,CAAUb,GAAV,EAAeY,qBAAf;AACH;;AAED,qBAAKhD,cAAL,CAAoBkC,KAAK,CAAC5B,GAAN,CAAU8B,GAAV,CAApB;;;;;;;AAEA,qBAAK9C,YAAL;;;;;;;;;;;;;;;;AAIR;;;;;;;;;;;qCAQiBb,E,EAAYK,e,EAA2BC,a,EAA4C;AAChG,UAAI,KAAK8C,WAAL,EAAJ,EAAwB;AACpB;AACH;;AAED,WAAKqB,OAAL,CAAazE,EAAb,EAAiBK,eAAjB,EAAkCC,aAAlC,EAAiD;AAC7C0D,QAAAA,MAAM,EAAE,CAAC1E,eAAD;AADqC,OAAjD;AAGH;;;;EA5QcM,I;;AA+QnB,eAAeG,IAAf","sourcesContent":["/**\n * @flow\n * @file Helper for the box file API\n * @author Box\n */\n\nimport queryString from 'query-string';\nimport getProp from 'lodash/get';\nimport { findMissingProperties, fillMissingProperties } from '../utils/fields';\nimport { getTypedFileId } from '../utils/file';\nimport { getBadItemError, getBadPermissionsError } from '../utils/error';\nimport {\n    CACHE_PREFIX_FILE,\n    ERROR_CODE_FETCH_FILE,\n    ERROR_CODE_GET_DOWNLOAD_URL,\n    FIELD_AUTHENTICATED_DOWNLOAD_URL,\n    FIELD_EXTENSION,\n    FIELD_IS_DOWNLOAD_AVAILABLE,\n    REPRESENTATIONS_RESPONSE_ERROR,\n    REPRESENTATIONS_RESPONSE_SUCCESS,\n    REPRESENTATIONS_RESPONSE_VIEWABLE,\n    X_REP_HINTS,\n} from '../constants';\nimport Item from './Item';\nimport { retryNumOfTimes } from '../utils/function';\nimport TokenService from '../utils/TokenService';\nimport type { RequestOptions, ElementsErrorCallback } from '../common/types/api';\nimport type { BoxItem, BoxItemVersion, FileRepresentation } from '../common/types/core';\nimport type APICache from '../utils/Cache';\n\nclass File extends Item {\n    /**\n     * Creates a key for the cache\n     *\n     * @param {string} id - Folder id\n     * @return {string} key\n     */\n    getCacheKey(id: string): string {\n        return `${CACHE_PREFIX_FILE}${id}`;\n    }\n\n    /**\n     * API URL for files\n     *\n     * @param {string} [id] - Optional file id\n     * @return {string} base url for files\n     */\n    getUrl(id: string): string {\n        const suffix: string = id ? `/${id}` : '';\n        return `${this.getBaseApiUrl()}/files${suffix}`;\n    }\n\n    /**\n     * API for getting download URL for files and file versions\n     *\n     * @param {string} fileId - File id\n     * @param {BoxItem|BoxItemVersion} fileOrFileVersion - File or file version to download\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {void}\n     */\n    async getDownloadUrl(\n        fileId: string,\n        fileOrFileVersion: BoxItem | BoxItemVersion,\n        successCallback: string => void,\n        errorCallback: ElementsErrorCallback,\n    ): Promise<void> {\n        this.errorCode = ERROR_CODE_GET_DOWNLOAD_URL;\n        this.errorCallback = errorCallback;\n        this.successCallback = successCallback;\n\n        const downloadAvailable = fileOrFileVersion[FIELD_IS_DOWNLOAD_AVAILABLE];\n        const downloadUrl = fileOrFileVersion[FIELD_AUTHENTICATED_DOWNLOAD_URL];\n        const token = await TokenService.getReadToken(getTypedFileId(fileId), this.options.token);\n\n        if (!downloadAvailable || !downloadUrl || !token) {\n            this.errorHandler(new Error('Download is missing required fields or token.'));\n            return;\n        }\n\n        const { query, url: downloadBaseUrl } = queryString.parseUrl(downloadUrl);\n        const downloadUrlParams = { ...query, access_token: token };\n        const downloadUrlQuery = queryString.stringify(downloadUrlParams);\n\n        this.successHandler(`${downloadBaseUrl}?${downloadUrlQuery}`);\n    }\n\n    /**\n     * Determines whether the call to the file representations API has completed\n     *\n     * @param {data: { FileRepresentation }} response\n     * @return {boolean}\n     */\n    isRepresentationsCallComplete(response: { data: FileRepresentation }): boolean {\n        const status = getProp(response, 'data.status.state');\n        return (\n            !status ||\n            status === REPRESENTATIONS_RESPONSE_ERROR ||\n            status === REPRESENTATIONS_RESPONSE_SUCCESS ||\n            status === REPRESENTATIONS_RESPONSE_VIEWABLE\n        );\n    }\n\n    /**\n     * Polls a representation's infoUrl, attempting to generate a representation\n     *\n     * @param {FileRepresentation} representation - representation that should have its info.url polled\n     * @return {Promise<FileRepresentation>} - representation updated with most current status\n     */\n    async generateRepresentation(representation: FileRepresentation): Promise<FileRepresentation> {\n        const infoUrl = getProp(representation, 'info.url');\n\n        if (!infoUrl) {\n            return representation;\n        }\n\n        return retryNumOfTimes(\n            (successCallback, errorCallback) =>\n                this.xhr\n                    .get({ successCallback, errorCallback, url: infoUrl })\n                    .then(response =>\n                        this.isRepresentationsCallComplete(response)\n                            ? successCallback(response.data)\n                            : errorCallback(response.data),\n                    )\n                    .catch(e => {\n                        errorCallback(e);\n                    }),\n            4,\n            2000,\n            2,\n        );\n    }\n\n    /**\n     * API for getting a thumbnail URL for a BoxItem\n     *\n     * @param {BoxItem} item - BoxItem to get the thumbnail URL for\n     * @return {Promise<?string>} - the url for the item's thumbnail, or null\n     */\n    async getThumbnailUrl(item: BoxItem): Promise<?string> {\n        const entry = getProp(item, 'representations.entries[0]');\n        const extension = getProp(entry, 'representation');\n        const template = getProp(entry, 'content.url_template');\n        const token = await TokenService.getReadToken(getTypedFileId(item.id), this.options.token);\n\n        if (!extension || !template || !token) {\n            return null;\n        }\n\n        const thumbnailUrl = template.replace('{+asset_path}', extension === 'jpg' ? '' : '1.png');\n        const { query, url: thumbnailBaseUrl } = queryString.parseUrl(thumbnailUrl);\n        const thumbnailUrlParams = { ...query, access_token: token };\n        const thumbnailUrlQuery = queryString.stringify(thumbnailUrlParams);\n        return `${thumbnailBaseUrl}?${thumbnailUrlQuery}`;\n    }\n\n    /**\n     * API for setting the description of a file\n     *\n     * @param {BoxItem} file - File object for which we are changing the description\n     * @param {string} description - New file description\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {Promise}\n     */\n    setFileDescription(\n        file: BoxItem,\n        description: string,\n        successCallback: Function,\n        errorCallback: Function,\n    ): Promise<void> {\n        const { id, permissions } = file;\n\n        if (!id || !permissions) {\n            errorCallback(getBadItemError());\n            return Promise.reject();\n        }\n\n        if (!permissions.can_rename) {\n            errorCallback(getBadPermissionsError());\n            return Promise.reject();\n        }\n\n        return this.xhr\n            .put({\n                id: getTypedFileId(id),\n                url: this.getUrl(id),\n                data: { description },\n            })\n            .then(({ data }: { data: BoxItem }) => {\n                if (!this.isDestroyed()) {\n                    const updatedFile = this.merge(this.getCacheKey(id), 'description', data.description);\n                    successCallback(updatedFile);\n                }\n            })\n            .catch(() => {\n                if (!this.isDestroyed()) {\n                    const originalFile = this.merge(this.getCacheKey(id), 'description', file.description);\n                    errorCallback(originalFile);\n                }\n            });\n    }\n\n    /**\n     * Gets a box file\n     *\n     * @param {string} id - File id\n     * @param {Function} successCallback - Function to call with results\n     * @param {Function} errorCallback - Function to call with errors\n     * @param {boolean|void} [options.fields] - Optionally include specific fields\n     * @param {boolean|void} [options.forceFetch] - Optionally Bypasses the cache\n     * @param {boolean|void} [options.refreshCache] - Optionally Updates the cache\n     * @return {Promise}\n     */\n    async getFile(\n        id: string,\n        successCallback: Function,\n        errorCallback: ElementsErrorCallback,\n        options: RequestOptions = {},\n    ): Promise<void> {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        const cache: APICache = this.getCache();\n        const key: string = this.getCacheKey(id);\n        const isCached: boolean = !options.forceFetch && cache.has(key);\n        const file: BoxItem = isCached ? cache.get(key) : { id };\n        let missingFields: Array<string> = findMissingProperties(file, options.fields);\n        const xhrOptions: Object = {\n            id: getTypedFileId(id),\n            url: this.getUrl(id),\n            headers: { 'X-Rep-Hints': X_REP_HINTS },\n        };\n        this.errorCode = ERROR_CODE_FETCH_FILE;\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n\n        // If the file was cached and there are no missing fields\n        // then just return the cached file and optionally refresh\n        // the cache with new data if required\n        if (isCached && missingFields.length === 0) {\n            successCallback(file);\n            missingFields = options.fields || [];\n            if (!options.refreshCache) {\n                return;\n            }\n        }\n\n        // If there are missing fields to fetch, add it to the params\n        if (missingFields.length > 0) {\n            xhrOptions.params = {\n                fields: missingFields.toString(),\n            };\n        }\n\n        try {\n            const { data } = await this.xhr.get(xhrOptions);\n            if (this.isDestroyed()) {\n                return;\n            }\n\n            // Merge fields that were requested but were actually not returned.\n            // This part is mostly useful for metadata.foo.bar fields since the API\n            // returns { metadata: null } instead of { metadata: { foo: { bar: null } } }\n            const dataWithMissingFields = fillMissingProperties(data, missingFields);\n\n            // Cache check is again done since this code is executed async\n            if (cache.has(key)) {\n                cache.merge(key, dataWithMissingFields);\n            } else {\n                // If there was nothing in the cache\n                cache.set(key, dataWithMissingFields);\n            }\n\n            this.successHandler(cache.get(key));\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n\n    /**\n     * Gets the extension of a box file.\n     *\n     * @param {string} id - File id\n     * @param {Function} successCallback - Function to call with results\n     * @param {Function} errorCallback - Function to call with errors\n     * @return {Promise}\n     */\n    getFileExtension(id: string, successCallback: Function, errorCallback: ElementsErrorCallback): void {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        this.getFile(id, successCallback, errorCallback, {\n            fields: [FIELD_EXTENSION],\n        });\n    }\n}\n\nexport default File;\n"],"file":"File.js"}