{"version":3,"sources":["../../src/api/MetadataQuery.js"],"names":["getProp","omit","Base","CACHE_PREFIX_METADATA_QUERY","ERROR_CODE_METADATA_QUERY","ITEM_TYPE_FILE","MetadataQuery","response","entries","next_marker","filter","entry","metadata","flattenedMetadata","Object","keys","forEach","scope","templateKey","nonconformingInstance","data","id","$id","metadataTemplate","type","item","name","size","flattenMetadata","items","map","flattenResponseEntry","nextMarker","cache","getCache","filteredResponse","filterMetdataQueryResponse","set","key","flattenMetdataQueryResponse","finish","getBaseApiUrl","has","isDestroyed","metadataQueryData","get","successCallback","query","errorCode","xhr","post","url","getUrl","then","queryMetadataSuccessHandler","catch","errorHandler","errorCallback","options","context","getCacheKey","forceFetch","unset","isLoaded","queryMetadataRequest"],"mappings":"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","sourcesContent":["/**\n * @flow\n * @file Helper for the box metadata query API\n * @author Box\n */\n\nimport getProp from 'lodash/get';\nimport omit from 'lodash/omit';\nimport Base from './Base';\nimport { CACHE_PREFIX_METADATA_QUERY, ERROR_CODE_METADATA_QUERY } from '../constants';\nimport { ITEM_TYPE_FILE } from '../common/constants';\nimport type {\n    MetadataQuery as MetadataQueryType,\n    FlattenedMetadataQueryResponse,\n    FlattenedMetadataQueryResponseEntry,\n    FlattenedMetadataQueryResponseEntryMetadata,\n    MetadataQueryResponse,\n    MetadataQueryResponseEntry,\n    MetadataQueryResponseEntryMetadata,\n} from '../common/types/metadataQueries';\n\nclass MetadataQuery extends Base {\n    /**\n     * @property {string}\n     */\n    key: string;\n\n    /**\n     * @property {Function}\n     */\n    successCallback: Function;\n\n    /**\n     * @property {Function}\n     */\n    errorCallback: ElementsErrorCallback;\n\n    /**\n     * Creates a key for the metadata cache\n     *\n     * @param {string} id - metadata template\n     * @return {string} key\n     */\n    getCacheKey(id: string): string {\n        return `${CACHE_PREFIX_METADATA_QUERY}${id}`;\n    }\n\n    /**\n     * API URL for metadata query\n     * @return {string} base url for files\n     */\n    getUrl(): string {\n        return `${this.getBaseApiUrl()}/metadata_queries/execute`;\n    }\n\n    /**\n     * Returns true for cache hit for metadata query results\n     *\n     * @return {boolean} if query results are loaded\n     */\n    isLoaded(): boolean {\n        const cache: APICache = this.getCache();\n        return cache.has(this.key);\n    }\n\n    /**\n     * Returns the results using successCallback\n     *\n     * @return {void}\n     */\n    finish(): void {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        const cache: APICache = this.getCache();\n        const metadataQueryData = cache.get(this.key);\n        this.successCallback(metadataQueryData);\n    }\n\n    /**\n     * Returns the response object with entries of type 'file' only.\n     *\n     * @param {Object} response\n     * @return {Object}\n     */\n    filterMetdataQueryResponse = (response: MetadataQueryResponse): MetadataQueryResponse => {\n        const { entries = [], next_marker } = response;\n        return {\n            entries: entries.filter(entry => getProp(entry, 'item.type') === ITEM_TYPE_FILE), // return only file items\n            next_marker,\n        };\n    };\n\n    /**\n     * Extracts flattened metadata from the metadata response object\n     * @param {Object} - metadata from the query response entry\n     * @return {Object} - flattened metadata entry without the $ fields\n     */\n    flattenMetadata = (metadata: MetadataQueryResponseEntryMetadata): FlattenedMetadataQueryResponseEntryMetadata => {\n        let flattenedMetadata = {};\n\n        Object.keys(metadata).forEach(scope => {\n            Object.keys(metadata[scope]).forEach(templateKey => {\n                const nonconformingInstance = metadata[scope][templateKey];\n                const data = omit(nonconformingInstance, [\n                    '$id',\n                    '$parent',\n                    '$type',\n                    '$typeScope',\n                    '$typeVersion',\n                    '$version',\n                ]);\n\n                flattenedMetadata = {\n                    data,\n                    id: nonconformingInstance.$id,\n                    metadataTemplate: {\n                        type: 'metadata-template',\n                        templateKey,\n                    },\n                };\n            });\n        });\n\n        return flattenedMetadata;\n    };\n\n    /**\n     * Converts metadata query response entry to a flattened one\n     * @param {Object} - metadata query response entry\n     * @return {Object} - flattened metadata query response entry\n     */\n    flattenResponseEntry = ({ item, metadata }: MetadataQueryResponseEntry): FlattenedMetadataQueryResponseEntry => {\n        const { id, name, size } = item;\n\n        return {\n            id,\n            metadata: this.flattenMetadata(metadata),\n            name,\n            size,\n        };\n    };\n\n    /**\n     * Flattens metadata query response\n     * @param {Object} - metadata query response object\n     * @return {Object} - flattened metadata query response object\n     */\n    flattenMetdataQueryResponse = ({ entries, next_marker }: MetadataQueryResponse): FlattenedMetadataQueryResponse => {\n        return {\n            items: entries.map<FlattenedMetadataQueryResponseEntry>(this.flattenResponseEntry),\n            nextMarker: next_marker,\n        };\n    };\n\n    /**\n     * @param {Object} response\n     */\n    queryMetadataSuccessHandler = ({ data }: { data: MetadataQueryResponse }): void => {\n        const cache: APICache = this.getCache();\n        const filteredResponse = this.filterMetdataQueryResponse(data);\n        // Flatten the filtered metadata query response and set it in cache\n        cache.set(this.key, this.flattenMetdataQueryResponse(filteredResponse));\n        this.finish();\n    };\n\n    /**\n     * Does the network request to metadata query API\n     * @param {Object} query query object with SQL Clauses like properties\n     * @return {void}\n     */\n    queryMetadataRequest(query: MetadataQueryType): void {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        this.errorCode = ERROR_CODE_METADATA_QUERY;\n        this.xhr\n            .post({\n                url: this.getUrl(),\n                data: query,\n            })\n            .then(this.queryMetadataSuccessHandler)\n            .catch(this.errorHandler);\n    }\n\n    /**\n     * API for querying enterprise metadata\n     * @param {Object} query - metadata query object\n     * @param {Function} successCallback - Function to call with results\n     * @param {Function} errorCallback - Function to call with errors\n     * @param {boolean|void} [options.forceFetch] - Bypasses the cache\n     * @return {void}\n     */\n    queryMetadata(\n        query: MetadataQueryType,\n        successCallback: Function,\n        errorCallback: ElementsErrorCallback,\n        options: Object = {},\n    ): void {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        const { context = {} } = options;\n        this.key = this.getCacheKey(context.id);\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n\n        // Clear the cache if needed\n        if (options.forceFetch) {\n            this.getCache().unset(this.key);\n        }\n\n        // Return the Cache value if it exists\n        if (this.isLoaded()) {\n            this.finish();\n            return;\n        }\n\n        // Make the XHR request\n        this.queryMetadataRequest(query);\n    }\n}\n\nexport default MetadataQuery;\n"],"file":"MetadataQuery.js"}