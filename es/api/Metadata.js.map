{"version":3,"sources":["../../src/api/Metadata.js"],"names":["getProp","uniqueId","getBadItemError","getBadPermissionsError","isUserCorrectableError","getTypedFileId","File","HEADER_CONTENT_TYPE","METADATA_SCOPE_ENTERPRISE","METADATA_SCOPE_GLOBAL","METADATA_TEMPLATE_FETCH_LIMIT","METADATA_TEMPLATE_PROPERTIES","METADATA_TEMPLATE_CLASSIFICATION","METADATA_TEMPLATE_SKILLS","FIELD_METADATA_SKILLS","CACHE_PREFIX_METADATA","ERROR_CODE_UPDATE_SKILLS","ERROR_CODE_UPDATE_METADATA","ERROR_CODE_CREATE_METADATA","ERROR_CODE_DELETE_METADATA","ERROR_CODE_FETCH_METADATA","ERROR_CODE_FETCH_METADATA_TEMPLATES","ERROR_CODE_FETCH_SKILLS","Metadata","id","getMetadataCacheKey","scope","template","baseUrl","getUrl","getBaseApiUrl","getMetadataTemplateUrl","templateKey","hidden","instance","canEdit","data","Object","keys","forEach","key","startsWith","$id","$canEdit","instanceId","errorCode","templates","url","getMetadataTemplateUrlForInstance","getMetadataTemplateUrlForScope","xhr","get","params","limit","status","instances","getMetadataUrl","customPropertiesTemplate","enterpriseTemplates","hasMetadataFeature","isExternallyOwned","userAddableTemplates","concat","filter","classification","find","$template","splice","indexOf","cache","getCache","getClassificationCacheKey","set","$scope","t","getTemplates","crossEnterpriseTemplate","globalTemplates","filteredInstances","extractClassification","editors","Promise","all","map","getTemplateForInstance","push","createEditor","file","successCallback","errorCallback","options","permissions","is_externally_owned","errorHandler","forceFetch","unset","has","successHandler","refreshCache","getCustomPropertiesTemplate","getInstances","resolve","getEditors","can_upload","metadata","getUserAddableTemplates","isDestroyed","getSkillsCacheKey","skills","cards","operations","put","headers","merge","getCacheKey","cachedMetadata","editor","findIndex","isProperties","post","delete"],"mappings":"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","sourcesContent":["/**\n * @flow\n * @file Helper for the Box metadata related API\n * @author Box\n */\n\nimport getProp from 'lodash/get';\nimport uniqueId from 'lodash/uniqueId';\nimport { getBadItemError, getBadPermissionsError, isUserCorrectableError } from '../utils/error';\nimport { getTypedFileId } from '../utils/file';\nimport File from './File';\nimport {\n    HEADER_CONTENT_TYPE,\n    METADATA_SCOPE_ENTERPRISE,\n    METADATA_SCOPE_GLOBAL,\n    METADATA_TEMPLATE_FETCH_LIMIT,\n    METADATA_TEMPLATE_PROPERTIES,\n    METADATA_TEMPLATE_CLASSIFICATION,\n    METADATA_TEMPLATE_SKILLS,\n    FIELD_METADATA_SKILLS,\n    CACHE_PREFIX_METADATA,\n    ERROR_CODE_UPDATE_SKILLS,\n    ERROR_CODE_UPDATE_METADATA,\n    ERROR_CODE_CREATE_METADATA,\n    ERROR_CODE_DELETE_METADATA,\n    ERROR_CODE_FETCH_METADATA,\n    ERROR_CODE_FETCH_METADATA_TEMPLATES,\n    ERROR_CODE_FETCH_SKILLS,\n} from '../constants';\n\nclass Metadata extends File {\n    /**\n     * Creates a key for the metadata cache\n     *\n     * @param {string} id - Folder id\n     * @return {string} key\n     */\n    getMetadataCacheKey(id: string): string {\n        return `${CACHE_PREFIX_METADATA}${id}`;\n    }\n\n    /**\n     * Creates a key for the skills cache\n     *\n     * @param {string} id - Folder id\n     * @return {string} key\n     */\n    getSkillsCacheKey(id: string): string {\n        return `${this.getMetadataCacheKey(id)}_skills`;\n    }\n\n    /**\n     * Creates a key for the classification cache\n     *\n     * @param {string} id - Folder id\n     * @return {string} key\n     */\n    getClassificationCacheKey(id: string): string {\n        return `${this.getMetadataCacheKey(id)}_classification`;\n    }\n\n    /**\n     * API URL for metadata\n     *\n     * @param {string} id - a Box file id\n     * @param {string} field - metadata field\n     * @return {string} base url for files\n     */\n    getMetadataUrl(id: string, scope?: string, template?: string): string {\n        const baseUrl = `${this.getUrl(id)}/metadata`;\n        if (scope && template) {\n            return `${baseUrl}/${scope}/${template}`;\n        }\n        return baseUrl;\n    }\n\n    /**\n     * API URL for metadata templates for a scope\n     *\n     * @param {string} scope - metadata scope\n     * @return {string} base url for files\n     */\n    getMetadataTemplateUrl(): string {\n        return `${this.getBaseApiUrl()}/metadata_templates`;\n    }\n\n    /**\n     * API URL for metadata template for an instance\n     *\n     * @param {string} id - metadata instance id\n     * @return {string} base url for files\n     */\n    getMetadataTemplateUrlForInstance(id: string): string {\n        return `${this.getMetadataTemplateUrl()}?metadata_instance_id=${id}`;\n    }\n\n    /**\n     * API URL for metadata templates\n     *\n     * @param {string} scope - metadata scope or id\n     * @return {string} base url for files\n     */\n    getMetadataTemplateUrlForScope(scope: string): string {\n        return `${this.getMetadataTemplateUrl()}/${scope}`;\n    }\n\n    /**\n     * Returns the custom properties template\n     *\n     * @return {Object} temaplte for custom properties\n     */\n    getCustomPropertiesTemplate(): MetadataTemplate {\n        return {\n            id: uniqueId('metadata_template_'),\n            scope: METADATA_SCOPE_GLOBAL,\n            templateKey: METADATA_TEMPLATE_PROPERTIES,\n            hidden: false,\n        };\n    }\n\n    /**\n     * Utility to create editors from metadata instances\n     * and metadata templates.\n     *\n     * @param {Object} instance - metadata instance\n     * @param {Object} template - metadata template\n     * @param {boolean} canEdit - is instance editable\n     * @return {Object} metadata editor\n     */\n    createEditor(instance: MetadataInstanceV2, template: MetadataTemplate, canEdit: boolean): MetadataEditor {\n        const data: MetadataFields = {};\n        Object.keys(instance).forEach(key => {\n            if (!key.startsWith('$')) {\n                // $FlowFixMe\n                data[key] = instance[key];\n            }\n        });\n\n        return {\n            template,\n            instance: {\n                id: instance.$id,\n                canEdit: instance.$canEdit && canEdit,\n                data,\n            },\n        };\n    }\n\n    /**\n     * Gets metadata templates for enterprise\n     *\n     * @param {string} id - file id\n     * @param {string} scope - metadata scope\n     * @param {string|void} [instanceId] - metadata instance id\n     * @return {Object} array of metadata templates\n     */\n    async getTemplates(id: string, scope: string, instanceId?: string): Promise<Array<MetadataTemplate>> {\n        this.errorCode = ERROR_CODE_FETCH_METADATA_TEMPLATES;\n        let templates = {};\n        const url = instanceId\n            ? this.getMetadataTemplateUrlForInstance(instanceId)\n            : this.getMetadataTemplateUrlForScope(scope);\n\n        try {\n            templates = await this.xhr.get({\n                url,\n                id: getTypedFileId(id),\n                params: {\n                    limit: METADATA_TEMPLATE_FETCH_LIMIT, // internal hard limit is 500\n                },\n            });\n        } catch (e) {\n            const { status } = e;\n            if (isUserCorrectableError(status)) {\n                throw e;\n            }\n        }\n\n        return getProp(templates, 'data.entries', []);\n    }\n\n    /**\n     * Gets metadata instances for a Box file\n     *\n     * @param {string} id - file id\n     * @return {Object} array of metadata instances\n     */\n    async getInstances(id: string): Promise<Array<MetadataInstanceV2>> {\n        this.errorCode = ERROR_CODE_FETCH_METADATA;\n        let instances = {};\n        try {\n            instances = await this.xhr.get({\n                url: this.getMetadataUrl(id),\n                id: getTypedFileId(id),\n            });\n        } catch (e) {\n            const { status } = e;\n            if (isUserCorrectableError(status)) {\n                throw e;\n            }\n        }\n        return getProp(instances, 'data.entries', []);\n    }\n\n    /**\n     * Returns a list of templates that can be added by the user.\n     * For collabed files, only custom properties is allowed.\n     *\n     * @return {Object} template for custom properties\n     */\n    getUserAddableTemplates(\n        customPropertiesTemplate: MetadataTemplate,\n        enterpriseTemplates: Array<MetadataTemplate>,\n        hasMetadataFeature: boolean,\n        isExternallyOwned?: boolean,\n    ): Array<MetadataTemplate> {\n        let userAddableTemplates: Array<MetadataTemplate> = [];\n        if (hasMetadataFeature) {\n            userAddableTemplates = isExternallyOwned\n                ? [customPropertiesTemplate]\n                : [customPropertiesTemplate].concat(enterpriseTemplates);\n        }\n        // Only templates that are not hidden and not classification\n        return userAddableTemplates.filter(\n            template => !template.hidden && template.templateKey !== METADATA_TEMPLATE_CLASSIFICATION,\n        );\n    }\n\n    /**\n     * Extracts classification for different representation in the UI.\n     *\n     * @param {string} id - Box file id\n     * @param {Array} instances - metadata instances\n     * @return {Array} metadata instances without classification\n     */\n    extractClassification(id: string, instances: Array<MetadataInstanceV2>): Array<MetadataInstanceV2> {\n        const classification = instances.find(instance => instance.$template === METADATA_TEMPLATE_CLASSIFICATION);\n        if (classification) {\n            instances.splice(instances.indexOf(classification), 1);\n            const cache: APICache = this.getCache();\n            const key = this.getClassificationCacheKey(id);\n            cache.set(key, classification);\n        }\n        return instances;\n    }\n\n    /**\n     * Finds template for a given metadata instance.\n     *\n     * @param {string} id - Box file id\n     * @param {Object} instance - metadata instance\n     * @param {Array} templates - metadata templates\n     * @return {Object|undefined} template for metadata instance\n     */\n    async getTemplateForInstance(\n        id: string,\n        instance: MetadataInstanceV2,\n        templates: Array<MetadataTemplate>,\n    ): Promise<?MetadataTemplate> {\n        const instanceId = instance.$id;\n        const templateKey = instance.$template;\n        const scope = instance.$scope;\n        let template = templates.find(t => t.templateKey === templateKey && t.scope === scope);\n\n        // Enterprise scopes are always enterprise_XXXXX\n        if (!template && scope.startsWith(METADATA_SCOPE_ENTERPRISE)) {\n            // If the template does not exist, it can be a template from another\n            // enterprise because the user is viewing a collaborated file.\n            const crossEnterpriseTemplate = await this.getTemplates(id, scope, instanceId);\n            // The API always returns an array of at most one item\n            template = crossEnterpriseTemplate[0]; // eslint-disable-line\n        }\n\n        return template;\n    }\n\n    /**\n     * Creates and returns metadata editors.\n     *\n     * @param {string} id - Box file id\n     * @param {Array} instances - metadata instances\n     * @param {Object} customPropertiesTemplate - custom properties template\n     * @param {Array} enterpriseTemplates - enterprise templates\n     * @param {Array} globalTemplates - global templates\n     * @param {boolean} canEdit - metadata editability\n     * @return {Array} metadata editors\n     */\n    async getEditors(\n        id: string,\n        instances: Array<MetadataInstanceV2>,\n        customPropertiesTemplate: MetadataTemplate,\n        enterpriseTemplates: Array<MetadataTemplate>,\n        globalTemplates: Array<MetadataTemplate>,\n        canEdit: boolean,\n    ): Promise<Array<MetadataEditor>> {\n        // All usable templates for metadata instances\n        const templates: Array<MetadataTemplate> = [customPropertiesTemplate].concat(\n            enterpriseTemplates,\n            globalTemplates,\n        );\n\n        // Filter out skills and classification\n        // let filteredInstances = this.extractSkills(id, instances);\n        const filteredInstances = this.extractClassification(id, instances);\n\n        // Create editors from each instance\n        const editors: Array<MetadataEditor> = [];\n        await Promise.all(\n            filteredInstances.map(async instance => {\n                const template: ?MetadataTemplate = await this.getTemplateForInstance(id, instance, templates);\n                if (template) {\n                    editors.push(this.createEditor(instance, template, canEdit));\n                }\n            }),\n        );\n        return editors;\n    }\n\n    /**\n     * API for getting metadata editors\n     *\n     * @param {string} fileId - Box file id\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @param {boolean} hasMetadataFeature - metadata feature check\n     * @param {Object} options - fetch options\n     * @return {Promise}\n     */\n    async getMetadata(\n        file: BoxItem,\n        successCallback: ({ editors: Array<MetadataEditor>, templates: Array<MetadataTemplate> }) => void,\n        errorCallback: ElementsErrorCallback,\n        hasMetadataFeature: boolean,\n        options: FetchOptions = {},\n    ): Promise<void> {\n        const { id, permissions, is_externally_owned }: BoxItem = file;\n        this.errorCode = ERROR_CODE_FETCH_METADATA;\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n\n        // Check for valid file object.\n        // Need to eventually check for upload permission.\n        if (!id || !permissions) {\n            this.errorHandler(getBadItemError());\n            return;\n        }\n\n        const cache: APICache = this.getCache();\n        const key = this.getMetadataCacheKey(id);\n\n        // Clear the cache if needed\n        if (options.forceFetch) {\n            cache.unset(key);\n        }\n\n        // Return the cached value if it exists\n        if (cache.has(key)) {\n            this.successHandler(cache.get(key));\n            if (!options.refreshCache) {\n                return;\n            }\n        }\n\n        try {\n            const customPropertiesTemplate: MetadataTemplate = this.getCustomPropertiesTemplate();\n            const [instances, globalTemplates, enterpriseTemplates] = await Promise.all([\n                this.getInstances(id),\n                this.getTemplates(id, METADATA_SCOPE_GLOBAL),\n                hasMetadataFeature ? this.getTemplates(id, METADATA_SCOPE_ENTERPRISE) : Promise.resolve([]),\n            ]);\n\n            const editors = await this.getEditors(\n                id,\n                instances,\n                customPropertiesTemplate,\n                enterpriseTemplates,\n                globalTemplates,\n                !!permissions.can_upload,\n            );\n\n            const metadata = {\n                editors,\n                templates: this.getUserAddableTemplates(\n                    customPropertiesTemplate,\n                    enterpriseTemplates,\n                    hasMetadataFeature,\n                    is_externally_owned,\n                ),\n            };\n\n            cache.set(key, metadata);\n\n            if (!this.isDestroyed()) {\n                this.successHandler(metadata);\n            }\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n\n    /**\n     * Gets skills for file\n     *\n     * @param {string} id - file id\n     * @return {Object} array of metadata instances\n     */\n    async getSkills(\n        file: BoxItem,\n        successCallback: Function,\n        errorCallback: ElementsErrorCallback,\n        forceFetch: boolean = false,\n    ): Promise<void> {\n        this.errorCode = ERROR_CODE_FETCH_SKILLS;\n        const { id }: BoxItem = file;\n        if (!id) {\n            errorCallback(getBadItemError(), this.errorCode);\n            return;\n        }\n\n        const cache: APICache = this.getCache();\n        const key = this.getSkillsCacheKey(id);\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n\n        // Clear the cache if needed\n        if (forceFetch) {\n            cache.unset(key);\n        }\n\n        // Return the Cache value if it exists\n        if (cache.has(key)) {\n            this.successHandler(cache.get(key));\n            return;\n        }\n\n        // The file object may already have skills in it\n        let skills = {\n            data: getProp(file, FIELD_METADATA_SKILLS),\n        };\n\n        try {\n            if (!skills.data) {\n                skills = await this.xhr.get({\n                    url: this.getMetadataUrl(id, METADATA_SCOPE_GLOBAL, METADATA_TEMPLATE_SKILLS),\n                    id: getTypedFileId(id),\n                });\n            }\n\n            if (!this.isDestroyed()) {\n                const cards = skills.data.cards || [];\n                cache.set(key, cards);\n                this.successHandler(cards);\n            }\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n\n    /**\n     * API for patching skills on a file\n     *\n     * @param {BoxItem} file - File object for which we are changing the description\n     * @param {string} field - Metadata field to patch\n     * @param {Array} operations - Array of JSON patch operations\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {Promise}\n     */\n    async updateSkills(\n        file: BoxItem,\n        operations: JSONPatchOperations,\n        successCallback: Function,\n        errorCallback: ElementsErrorCallback,\n    ): Promise<void> {\n        this.errorCode = ERROR_CODE_UPDATE_SKILLS;\n        const { id, permissions } = file;\n        if (!id || !permissions) {\n            errorCallback(getBadItemError(), this.errorCode);\n            return;\n        }\n\n        if (!permissions.can_upload) {\n            errorCallback(getBadPermissionsError(), this.errorCode);\n            return;\n        }\n\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n\n        try {\n            const metadata = await this.xhr.put({\n                url: this.getMetadataUrl(id, METADATA_SCOPE_GLOBAL, METADATA_TEMPLATE_SKILLS),\n                headers: {\n                    [HEADER_CONTENT_TYPE]: 'application/json-patch+json',\n                },\n                id: getTypedFileId(id),\n                data: operations,\n            });\n            if (!this.isDestroyed()) {\n                const cards = metadata.data.cards || [];\n                this.merge(this.getCacheKey(id), FIELD_METADATA_SKILLS, metadata.data);\n                this.getCache().set(this.getSkillsCacheKey(id), cards);\n                this.successHandler(cards);\n            }\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n\n    /**\n     * API for patching metadata on file\n     *\n     * @param {BoxItem} file - File object for which we are changing the description\n     * @param {Object} template - Metadata template\n     * @param {Array} operations - Array of JSON patch operations\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {Promise}\n     */\n    async updateMetadata(\n        file: BoxItem,\n        template: MetadataTemplate,\n        operations: JSONPatchOperations,\n        successCallback: Function,\n        errorCallback: ElementsErrorCallback,\n    ): Promise<void> {\n        this.errorCode = ERROR_CODE_UPDATE_METADATA;\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n\n        const { id, permissions } = file;\n        if (!id || !permissions) {\n            this.errorHandler(getBadItemError());\n            return;\n        }\n\n        const canEdit = !!permissions.can_upload;\n\n        if (!canEdit) {\n            this.errorHandler(getBadPermissionsError());\n            return;\n        }\n\n        try {\n            const metadata = await this.xhr.put({\n                url: this.getMetadataUrl(id, template.scope, template.templateKey),\n                headers: {\n                    [HEADER_CONTENT_TYPE]: 'application/json-patch+json',\n                },\n                id: getTypedFileId(id),\n                data: operations,\n            });\n            if (!this.isDestroyed()) {\n                const cache: APICache = this.getCache();\n                const key = this.getMetadataCacheKey(id);\n                const cachedMetadata = cache.get(key);\n                const editor = this.createEditor(metadata.data, template, canEdit);\n                cachedMetadata.editors.splice(\n                    cachedMetadata.editors.findIndex(({ instance }) => instance.id === editor.instance.id),\n                    1,\n                    editor,\n                );\n                this.successHandler(editor);\n            }\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n\n    /**\n     * API for creating metadata on file\n     *\n     * @param {BoxItem} file - File object for which we are changing the description\n     * @param {Object} template - Metadata template\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {Promise}\n     */\n    async createMetadata(\n        file: BoxItem,\n        template: MetadataTemplate,\n        successCallback: Function,\n        errorCallback: ElementsErrorCallback,\n    ): Promise<void> {\n        this.errorCode = ERROR_CODE_CREATE_METADATA;\n        if (!file || !template) {\n            errorCallback(getBadItemError(), this.errorCode);\n            return;\n        }\n\n        const { id, permissions, is_externally_owned }: BoxItem = file;\n\n        if (!id || !permissions) {\n            errorCallback(getBadItemError(), this.errorCode);\n            return;\n        }\n\n        const canEdit = !!permissions.can_upload;\n        const isProperties =\n            template.templateKey === METADATA_TEMPLATE_PROPERTIES && template.scope === METADATA_SCOPE_GLOBAL;\n\n        if (!canEdit || (is_externally_owned && !isProperties)) {\n            errorCallback(getBadPermissionsError(), this.errorCode);\n            return;\n        }\n\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n\n        try {\n            const metadata = await this.xhr.post({\n                url: this.getMetadataUrl(id, template.scope, template.templateKey),\n                id: getTypedFileId(id),\n                data: {},\n            });\n            if (!this.isDestroyed()) {\n                const cache: APICache = this.getCache();\n                const key = this.getMetadataCacheKey(id);\n                const cachedMetadata = cache.get(key);\n                const editor = this.createEditor(metadata.data, template, canEdit);\n                cachedMetadata.editors.push(editor);\n                this.successHandler(editor);\n            }\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n\n    /**\n     * API for deleting metadata on file\n     *\n     * @param {BoxItem} file - File object for which we are changing the description\n     * @param {string} scope - Metadata instance scope\n     * @param {string} template - Metadata template key\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {Promise}\n     */\n    async deleteMetadata(\n        file: BoxItem,\n        template: MetadataTemplate,\n        successCallback: Function,\n        errorCallback: ElementsErrorCallback,\n    ): Promise<void> {\n        this.errorCode = ERROR_CODE_DELETE_METADATA;\n        if (!file || !template) {\n            errorCallback(getBadItemError(), this.errorCode);\n            return;\n        }\n\n        const { scope, templateKey }: MetadataTemplate = template;\n        const { id, permissions }: BoxItem = file;\n\n        if (!id || !permissions) {\n            errorCallback(getBadItemError(), this.errorCode);\n            return;\n        }\n\n        if (!permissions.can_upload) {\n            errorCallback(getBadPermissionsError(), this.errorCode);\n            return;\n        }\n\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n\n        try {\n            await this.xhr.delete({\n                url: this.getMetadataUrl(id, scope, templateKey),\n                id: getTypedFileId(id),\n            });\n            if (!this.isDestroyed()) {\n                const cache: APICache = this.getCache();\n                const key = this.getMetadataCacheKey(id);\n                const metadata = cache.get(key);\n                metadata.editors.splice(\n                    metadata.editors.findIndex(\n                        editor => editor.template.scope === scope && editor.template.templateKey === templateKey,\n                    ),\n                    1,\n                );\n                this.successHandler();\n            }\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n}\n\nexport default Metadata;\n"],"file":"Metadata.js"}