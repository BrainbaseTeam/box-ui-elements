{"version":3,"sources":["../../src/api/Metadata.js"],"names":["getProp","uniqueId","getBadItemError","getBadPermissionsError","isUserCorrectableError","getTypedFileId","File","HEADER_CONTENT_TYPE","METADATA_SCOPE_ENTERPRISE","METADATA_SCOPE_GLOBAL","METADATA_TEMPLATE_FETCH_LIMIT","METADATA_TEMPLATE_PROPERTIES","METADATA_TEMPLATE_CLASSIFICATION","METADATA_TEMPLATE_SKILLS","FIELD_METADATA_SKILLS","CACHE_PREFIX_METADATA","ERROR_CODE_UPDATE_SKILLS","ERROR_CODE_UPDATE_METADATA","ERROR_CODE_CREATE_METADATA","ERROR_CODE_DELETE_METADATA","ERROR_CODE_FETCH_METADATA","ERROR_CODE_FETCH_METADATA_TEMPLATES","ERROR_CODE_FETCH_SKILLS","Metadata","id","getMetadataCacheKey","scope","template","baseUrl","getUrl","getBaseApiUrl","getMetadataTemplateUrl","templateKey","hidden","instance","canEdit","data","Object","keys","forEach","key","startsWith","$id","$canEdit","instanceId","errorCode","templates","url","getMetadataTemplateUrlForInstance","getMetadataTemplateUrlForScope","xhr","get","params","limit","status","getMetadataTemplateSchemaUrl","instances","getMetadataUrl","customPropertiesTemplate","enterpriseTemplates","hasMetadataFeature","isExternallyOwned","userAddableTemplates","concat","filter","classification","find","$template","splice","indexOf","cache","getCache","getClassificationCacheKey","set","$scope","t","getTemplates","crossEnterpriseTemplate","globalTemplates","filteredInstances","extractClassification","editors","Promise","all","map","getTemplateForInstance","push","createEditor","file","successCallback","errorCallback","options","permissions","is_externally_owned","errorHandler","forceFetch","unset","has","successHandler","refreshCache","getCustomPropertiesTemplate","getInstances","resolve","getEditors","can_upload","metadata","getUserAddableTemplates","isDestroyed","getSkillsCacheKey","skills","cards","operations","put","headers","merge","getCacheKey","cachedMetadata","editor","findIndex","isProperties","post","delete"],"mappings":"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","sourcesContent":["/**\n * @flow\n * @file Helper for the Box metadata related API\n * @author Box\n */\n\nimport getProp from 'lodash/get';\nimport uniqueId from 'lodash/uniqueId';\nimport { getBadItemError, getBadPermissionsError, isUserCorrectableError } from '../utils/error';\nimport { getTypedFileId } from '../utils/file';\nimport File from './File';\nimport {\n    HEADER_CONTENT_TYPE,\n    METADATA_SCOPE_ENTERPRISE,\n    METADATA_SCOPE_GLOBAL,\n    METADATA_TEMPLATE_FETCH_LIMIT,\n    METADATA_TEMPLATE_PROPERTIES,\n    METADATA_TEMPLATE_CLASSIFICATION,\n    METADATA_TEMPLATE_SKILLS,\n    FIELD_METADATA_SKILLS,\n    CACHE_PREFIX_METADATA,\n    ERROR_CODE_UPDATE_SKILLS,\n    ERROR_CODE_UPDATE_METADATA,\n    ERROR_CODE_CREATE_METADATA,\n    ERROR_CODE_DELETE_METADATA,\n    ERROR_CODE_FETCH_METADATA,\n    ERROR_CODE_FETCH_METADATA_TEMPLATES,\n    ERROR_CODE_FETCH_SKILLS,\n} from '../constants';\n\nimport type { RequestOptions, ElementsErrorCallback, JSONPatchOperations } from '../common/types/api';\nimport type {\n    MetadataTemplateSchemaResponse,\n    MetadataTemplate,\n    MetadataInstanceV2,\n    MetadataEditor,\n    MetadataFields,\n} from '../common/types/metadata';\nimport type { BoxItem } from '../common/types/core';\nimport type APICache from '../utils/Cache';\n\nclass Metadata extends File {\n    /**\n     * Creates a key for the metadata cache\n     *\n     * @param {string} id - Folder id\n     * @return {string} key\n     */\n    getMetadataCacheKey(id: string): string {\n        return `${CACHE_PREFIX_METADATA}${id}`;\n    }\n\n    /**\n     * Creates a key for the skills cache\n     *\n     * @param {string} id - Folder id\n     * @return {string} key\n     */\n    getSkillsCacheKey(id: string): string {\n        return `${this.getMetadataCacheKey(id)}_skills`;\n    }\n\n    /**\n     * Creates a key for the classification cache\n     *\n     * @param {string} id - Folder id\n     * @return {string} key\n     */\n    getClassificationCacheKey(id: string): string {\n        return `${this.getMetadataCacheKey(id)}_classification`;\n    }\n\n    /**\n     * API URL for metadata\n     *\n     * @param {string} id - a Box file id\n     * @param {string} field - metadata field\n     * @return {string} base url for files\n     */\n    getMetadataUrl(id: string, scope?: string, template?: string): string {\n        const baseUrl = `${this.getUrl(id)}/metadata`;\n        if (scope && template) {\n            return `${baseUrl}/${scope}/${template}`;\n        }\n        return baseUrl;\n    }\n\n    /**\n     * API URL for metadata templates for a scope\n     *\n     * @param {string} scope - metadata scope\n     * @return {string} base url for files\n     */\n    getMetadataTemplateUrl(): string {\n        return `${this.getBaseApiUrl()}/metadata_templates`;\n    }\n\n    /**\n     * API URL for metadata template for an instance\n     *\n     * @param {string} id - metadata instance id\n     * @return {string} base url for files\n     */\n    getMetadataTemplateUrlForInstance(id: string): string {\n        return `${this.getMetadataTemplateUrl()}?metadata_instance_id=${id}`;\n    }\n\n    /**\n     * API URL for getting metadata template schema by template key\n     *\n     * @param {string} templateKey - metadata template key\n     * @return {string} API url for getting template schema by template key\n     */\n    getMetadataTemplateSchemaUrl(templateKey: string): string {\n        return `${this.getMetadataTemplateUrl()}/enterprise/${templateKey}/schema`;\n    }\n\n    /**\n     * API URL for metadata templates\n     *\n     * @param {string} scope - metadata scope or id\n     * @return {string} base url for files\n     */\n    getMetadataTemplateUrlForScope(scope: string): string {\n        return `${this.getMetadataTemplateUrl()}/${scope}`;\n    }\n\n    /**\n     * Returns the custom properties template\n     *\n     * @return {Object} temaplte for custom properties\n     */\n    getCustomPropertiesTemplate(): MetadataTemplate {\n        return {\n            id: uniqueId('metadata_template_'),\n            scope: METADATA_SCOPE_GLOBAL,\n            templateKey: METADATA_TEMPLATE_PROPERTIES,\n            hidden: false,\n        };\n    }\n\n    /**\n     * Utility to create editors from metadata instances\n     * and metadata templates.\n     *\n     * @param {Object} instance - metadata instance\n     * @param {Object} template - metadata template\n     * @param {boolean} canEdit - is instance editable\n     * @return {Object} metadata editor\n     */\n    createEditor(instance: MetadataInstanceV2, template: MetadataTemplate, canEdit: boolean): MetadataEditor {\n        const data: MetadataFields = {};\n        Object.keys(instance).forEach(key => {\n            if (!key.startsWith('$')) {\n                // $FlowFixMe\n                data[key] = instance[key];\n            }\n        });\n\n        return {\n            template,\n            instance: {\n                id: instance.$id,\n                canEdit: instance.$canEdit && canEdit,\n                data,\n            },\n        };\n    }\n\n    /**\n     * Gets metadata templates for enterprise\n     *\n     * @param {string} id - file id\n     * @param {string} scope - metadata scope\n     * @param {string|void} [instanceId] - metadata instance id\n     * @return {Object} array of metadata templates\n     */\n    async getTemplates(id: string, scope: string, instanceId?: string): Promise<Array<MetadataTemplate>> {\n        this.errorCode = ERROR_CODE_FETCH_METADATA_TEMPLATES;\n        let templates = {};\n        const url = instanceId\n            ? this.getMetadataTemplateUrlForInstance(instanceId)\n            : this.getMetadataTemplateUrlForScope(scope);\n\n        try {\n            templates = await this.xhr.get({\n                url,\n                id: getTypedFileId(id),\n                params: {\n                    limit: METADATA_TEMPLATE_FETCH_LIMIT, // internal hard limit is 500\n                },\n            });\n        } catch (e) {\n            const { status } = e;\n            if (isUserCorrectableError(status)) {\n                throw e;\n            }\n        }\n\n        return getProp(templates, 'data.entries', []);\n    }\n\n    /**\n     * Gets metadata template schema by template key\n     *\n     * @param {string} templateKey - template key\n     * @return {Promise} Promise object of metadata template\n     */\n    getSchemaByTemplateKey(templateKey: string): Promise<MetadataTemplateSchemaResponse> {\n        const url = this.getMetadataTemplateSchemaUrl(templateKey);\n        return this.xhr.get({ url });\n    }\n\n    /**\n     * Gets metadata instances for a Box file\n     *\n     * @param {string} id - file id\n     * @return {Object} array of metadata instances\n     */\n    async getInstances(id: string): Promise<Array<MetadataInstanceV2>> {\n        this.errorCode = ERROR_CODE_FETCH_METADATA;\n        let instances = {};\n        try {\n            instances = await this.xhr.get({\n                url: this.getMetadataUrl(id),\n                id: getTypedFileId(id),\n            });\n        } catch (e) {\n            const { status } = e;\n            if (isUserCorrectableError(status)) {\n                throw e;\n            }\n        }\n        return getProp(instances, 'data.entries', []);\n    }\n\n    /**\n     * Returns a list of templates that can be added by the user.\n     * For collabed files, only custom properties is allowed.\n     *\n     * @return {Object} template for custom properties\n     */\n    getUserAddableTemplates(\n        customPropertiesTemplate: MetadataTemplate,\n        enterpriseTemplates: Array<MetadataTemplate>,\n        hasMetadataFeature: boolean,\n        isExternallyOwned?: boolean,\n    ): Array<MetadataTemplate> {\n        let userAddableTemplates: Array<MetadataTemplate> = [];\n        if (hasMetadataFeature) {\n            userAddableTemplates = isExternallyOwned\n                ? [customPropertiesTemplate]\n                : [customPropertiesTemplate].concat(enterpriseTemplates);\n        }\n        // Only templates that are not hidden and not classification\n        return userAddableTemplates.filter(\n            template => !template.hidden && template.templateKey !== METADATA_TEMPLATE_CLASSIFICATION,\n        );\n    }\n\n    /**\n     * Extracts classification for different representation in the UI.\n     *\n     * @param {string} id - Box file id\n     * @param {Array} instances - metadata instances\n     * @return {Array} metadata instances without classification\n     */\n    extractClassification(id: string, instances: Array<MetadataInstanceV2>): Array<MetadataInstanceV2> {\n        const classification = instances.find(instance => instance.$template === METADATA_TEMPLATE_CLASSIFICATION);\n        if (classification) {\n            instances.splice(instances.indexOf(classification), 1);\n            const cache: APICache = this.getCache();\n            const key = this.getClassificationCacheKey(id);\n            cache.set(key, classification);\n        }\n        return instances;\n    }\n\n    /**\n     * Finds template for a given metadata instance.\n     *\n     * @param {string} id - Box file id\n     * @param {Object} instance - metadata instance\n     * @param {Array} templates - metadata templates\n     * @return {Object|undefined} template for metadata instance\n     */\n    async getTemplateForInstance(\n        id: string,\n        instance: MetadataInstanceV2,\n        templates: Array<MetadataTemplate>,\n    ): Promise<?MetadataTemplate> {\n        const instanceId = instance.$id;\n        const templateKey = instance.$template;\n        const scope = instance.$scope;\n        let template = templates.find(t => t.templateKey === templateKey && t.scope === scope);\n\n        // Enterprise scopes are always enterprise_XXXXX\n        if (!template && scope.startsWith(METADATA_SCOPE_ENTERPRISE)) {\n            // If the template does not exist, it can be a template from another\n            // enterprise because the user is viewing a collaborated file.\n            const crossEnterpriseTemplate = await this.getTemplates(id, scope, instanceId);\n            // The API always returns an array of at most one item\n            template = crossEnterpriseTemplate[0]; // eslint-disable-line\n        }\n\n        return template;\n    }\n\n    /**\n     * Creates and returns metadata editors.\n     *\n     * @param {string} id - Box file id\n     * @param {Array} instances - metadata instances\n     * @param {Object} customPropertiesTemplate - custom properties template\n     * @param {Array} enterpriseTemplates - enterprise templates\n     * @param {Array} globalTemplates - global templates\n     * @param {boolean} canEdit - metadata editability\n     * @return {Array} metadata editors\n     */\n    async getEditors(\n        id: string,\n        instances: Array<MetadataInstanceV2>,\n        customPropertiesTemplate: MetadataTemplate,\n        enterpriseTemplates: Array<MetadataTemplate>,\n        globalTemplates: Array<MetadataTemplate>,\n        canEdit: boolean,\n    ): Promise<Array<MetadataEditor>> {\n        // All usable templates for metadata instances\n        const templates: Array<MetadataTemplate> = [customPropertiesTemplate].concat(\n            enterpriseTemplates,\n            globalTemplates,\n        );\n\n        // Filter out skills and classification\n        // let filteredInstances = this.extractSkills(id, instances);\n        const filteredInstances = this.extractClassification(id, instances);\n\n        // Create editors from each instance\n        const editors: Array<MetadataEditor> = [];\n        await Promise.all(\n            filteredInstances.map(async instance => {\n                const template: ?MetadataTemplate = await this.getTemplateForInstance(id, instance, templates);\n                if (template) {\n                    editors.push(this.createEditor(instance, template, canEdit));\n                }\n            }),\n        );\n        return editors;\n    }\n\n    /**\n     * API for getting metadata editors\n     *\n     * @param {string} fileId - Box file id\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @param {boolean} hasMetadataFeature - metadata feature check\n     * @param {Object} options - fetch options\n     * @return {Promise}\n     */\n    async getMetadata(\n        file: BoxItem,\n        successCallback: ({ editors: Array<MetadataEditor>, templates: Array<MetadataTemplate> }) => void,\n        errorCallback: ElementsErrorCallback,\n        hasMetadataFeature: boolean,\n        options: RequestOptions = {},\n    ): Promise<void> {\n        const { id, permissions, is_externally_owned }: BoxItem = file;\n        this.errorCode = ERROR_CODE_FETCH_METADATA;\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n\n        // Check for valid file object.\n        // Need to eventually check for upload permission.\n        if (!id || !permissions) {\n            this.errorHandler(getBadItemError());\n            return;\n        }\n\n        const cache: APICache = this.getCache();\n        const key = this.getMetadataCacheKey(id);\n\n        // Clear the cache if needed\n        if (options.forceFetch) {\n            cache.unset(key);\n        }\n\n        // Return the cached value if it exists\n        if (cache.has(key)) {\n            this.successHandler(cache.get(key));\n            if (!options.refreshCache) {\n                return;\n            }\n        }\n\n        try {\n            const customPropertiesTemplate: MetadataTemplate = this.getCustomPropertiesTemplate();\n            const [instances, globalTemplates, enterpriseTemplates] = await Promise.all([\n                this.getInstances(id),\n                this.getTemplates(id, METADATA_SCOPE_GLOBAL),\n                hasMetadataFeature ? this.getTemplates(id, METADATA_SCOPE_ENTERPRISE) : Promise.resolve([]),\n            ]);\n\n            const editors = await this.getEditors(\n                id,\n                instances,\n                customPropertiesTemplate,\n                enterpriseTemplates,\n                globalTemplates,\n                !!permissions.can_upload,\n            );\n\n            const metadata = {\n                editors,\n                templates: this.getUserAddableTemplates(\n                    customPropertiesTemplate,\n                    enterpriseTemplates,\n                    hasMetadataFeature,\n                    is_externally_owned,\n                ),\n            };\n\n            cache.set(key, metadata);\n\n            if (!this.isDestroyed()) {\n                this.successHandler(metadata);\n            }\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n\n    /**\n     * Gets skills for file\n     *\n     * @param {string} id - file id\n     * @return {Object} array of metadata instances\n     */\n    async getSkills(\n        file: BoxItem,\n        successCallback: Function,\n        errorCallback: ElementsErrorCallback,\n        forceFetch: boolean = false,\n    ): Promise<void> {\n        this.errorCode = ERROR_CODE_FETCH_SKILLS;\n        const { id }: BoxItem = file;\n        if (!id) {\n            errorCallback(getBadItemError(), this.errorCode);\n            return;\n        }\n\n        const cache: APICache = this.getCache();\n        const key = this.getSkillsCacheKey(id);\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n\n        // Clear the cache if needed\n        if (forceFetch) {\n            cache.unset(key);\n        }\n\n        // Return the Cache value if it exists\n        if (cache.has(key)) {\n            this.successHandler(cache.get(key));\n            return;\n        }\n\n        // The file object may already have skills in it\n        let skills = {\n            data: getProp(file, FIELD_METADATA_SKILLS),\n        };\n\n        try {\n            if (!skills.data) {\n                skills = await this.xhr.get({\n                    url: this.getMetadataUrl(id, METADATA_SCOPE_GLOBAL, METADATA_TEMPLATE_SKILLS),\n                    id: getTypedFileId(id),\n                });\n            }\n\n            if (!this.isDestroyed()) {\n                const cards = skills.data.cards || [];\n                cache.set(key, cards);\n                this.successHandler(cards);\n            }\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n\n    /**\n     * API for patching skills on a file\n     *\n     * @param {BoxItem} file - File object for which we are changing the description\n     * @param {string} field - Metadata field to patch\n     * @param {Array} operations - Array of JSON patch operations\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {Promise}\n     */\n    async updateSkills(\n        file: BoxItem,\n        operations: JSONPatchOperations,\n        successCallback: Function,\n        errorCallback: ElementsErrorCallback,\n    ): Promise<void> {\n        this.errorCode = ERROR_CODE_UPDATE_SKILLS;\n        const { id, permissions } = file;\n        if (!id || !permissions) {\n            errorCallback(getBadItemError(), this.errorCode);\n            return;\n        }\n\n        if (!permissions.can_upload) {\n            errorCallback(getBadPermissionsError(), this.errorCode);\n            return;\n        }\n\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n\n        try {\n            const metadata = await this.xhr.put({\n                url: this.getMetadataUrl(id, METADATA_SCOPE_GLOBAL, METADATA_TEMPLATE_SKILLS),\n                headers: {\n                    [HEADER_CONTENT_TYPE]: 'application/json-patch+json',\n                },\n                id: getTypedFileId(id),\n                data: operations,\n            });\n            if (!this.isDestroyed()) {\n                const cards = metadata.data.cards || [];\n                this.merge(this.getCacheKey(id), FIELD_METADATA_SKILLS, metadata.data);\n                this.getCache().set(this.getSkillsCacheKey(id), cards);\n                this.successHandler(cards);\n            }\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n\n    /**\n     * API for patching metadata on file\n     *\n     * @param {BoxItem} file - File object for which we are changing the description\n     * @param {Object} template - Metadata template\n     * @param {Array} operations - Array of JSON patch operations\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {Promise}\n     */\n    async updateMetadata(\n        file: BoxItem,\n        template: MetadataTemplate,\n        operations: JSONPatchOperations,\n        successCallback: Function,\n        errorCallback: ElementsErrorCallback,\n    ): Promise<void> {\n        this.errorCode = ERROR_CODE_UPDATE_METADATA;\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n\n        const { id, permissions } = file;\n        if (!id || !permissions) {\n            this.errorHandler(getBadItemError());\n            return;\n        }\n\n        const canEdit = !!permissions.can_upload;\n\n        if (!canEdit) {\n            this.errorHandler(getBadPermissionsError());\n            return;\n        }\n\n        try {\n            const metadata = await this.xhr.put({\n                url: this.getMetadataUrl(id, template.scope, template.templateKey),\n                headers: {\n                    [HEADER_CONTENT_TYPE]: 'application/json-patch+json',\n                },\n                id: getTypedFileId(id),\n                data: operations,\n            });\n            if (!this.isDestroyed()) {\n                const cache: APICache = this.getCache();\n                const key = this.getMetadataCacheKey(id);\n                const cachedMetadata = cache.get(key);\n                const editor = this.createEditor(metadata.data, template, canEdit);\n                if (cachedMetadata && cachedMetadata.editors) {\n                    cachedMetadata.editors.splice(\n                        cachedMetadata.editors.findIndex(({ instance }) => instance.id === editor.instance.id),\n                        1,\n                        editor,\n                    );\n                }\n                this.successHandler(editor);\n            }\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n\n    /**\n     * API for creating metadata on file\n     *\n     * @param {BoxItem} file - File object for which we are changing the description\n     * @param {Object} template - Metadata template\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {Promise}\n     */\n    async createMetadata(\n        file: BoxItem,\n        template: MetadataTemplate,\n        successCallback: Function,\n        errorCallback: ElementsErrorCallback,\n    ): Promise<void> {\n        this.errorCode = ERROR_CODE_CREATE_METADATA;\n        if (!file || !template) {\n            errorCallback(getBadItemError(), this.errorCode);\n            return;\n        }\n\n        const { id, permissions, is_externally_owned }: BoxItem = file;\n\n        if (!id || !permissions) {\n            errorCallback(getBadItemError(), this.errorCode);\n            return;\n        }\n\n        const canEdit = !!permissions.can_upload;\n        const isProperties =\n            template.templateKey === METADATA_TEMPLATE_PROPERTIES && template.scope === METADATA_SCOPE_GLOBAL;\n\n        if (!canEdit || (is_externally_owned && !isProperties)) {\n            errorCallback(getBadPermissionsError(), this.errorCode);\n            return;\n        }\n\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n\n        try {\n            const metadata = await this.xhr.post({\n                url: this.getMetadataUrl(id, template.scope, template.templateKey),\n                id: getTypedFileId(id),\n                data: {},\n            });\n            if (!this.isDestroyed()) {\n                const cache: APICache = this.getCache();\n                const key = this.getMetadataCacheKey(id);\n                const cachedMetadata = cache.get(key);\n                const editor = this.createEditor(metadata.data, template, canEdit);\n                cachedMetadata.editors.push(editor);\n                this.successHandler(editor);\n            }\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n\n    /**\n     * API for deleting metadata on file\n     *\n     * @param {BoxItem} file - File object for which we are changing the description\n     * @param {string} scope - Metadata instance scope\n     * @param {string} template - Metadata template key\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {Promise}\n     */\n    async deleteMetadata(\n        file: BoxItem,\n        template: MetadataTemplate,\n        successCallback: Function,\n        errorCallback: ElementsErrorCallback,\n    ): Promise<void> {\n        this.errorCode = ERROR_CODE_DELETE_METADATA;\n        if (!file || !template) {\n            errorCallback(getBadItemError(), this.errorCode);\n            return;\n        }\n\n        const { scope, templateKey }: MetadataTemplate = template;\n        const { id, permissions }: BoxItem = file;\n\n        if (!id || !permissions) {\n            errorCallback(getBadItemError(), this.errorCode);\n            return;\n        }\n\n        if (!permissions.can_upload) {\n            errorCallback(getBadPermissionsError(), this.errorCode);\n            return;\n        }\n\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n\n        try {\n            await this.xhr.delete({\n                url: this.getMetadataUrl(id, scope, templateKey),\n                id: getTypedFileId(id),\n            });\n            if (!this.isDestroyed()) {\n                const cache: APICache = this.getCache();\n                const key = this.getMetadataCacheKey(id);\n                const metadata = cache.get(key);\n                metadata.editors.splice(\n                    metadata.editors.findIndex(\n                        editor => editor.template.scope === scope && editor.template.templateKey === templateKey,\n                    ),\n                    1,\n                );\n                this.successHandler();\n            }\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n}\n\nexport default Metadata;\n"],"file":"Metadata.js"}