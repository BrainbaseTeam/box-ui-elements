{"version":3,"sources":["../../../src/api/uploads/FolderUploadNode.js"],"names":["noop","getFileFromEntry","FolderAPI","STATUS_COMPLETE","STATUS_ERROR","ERROR_CODE_UPLOAD_CHILD_FOLDER_FAILED","ERROR_CODE_ITEM_NAME_IN_USE","FolderUploadNode","name","addFilesToUploadQueue","addFolderToUploadQueue","fileAPIOptions","baseAPIOptions","entry","errorCallback","folders","Object","values","promises","map","folder","upload","folderId","Promise","all","isRoot","buildCurrentFolderFromEntry","errorEncountered","errorCode","createFolder","data","id","code","context_info","conflicts","folderObject","extension","status","isFolder","size","progress","error","files","file","options","uploadInitTimestamp","Date","now","entries","isFile","push","reader","resolve","readEntries","length","createFolderUploadNodesFromEntries","readEntry","createReader","parentFolderId","createAndUploadFolder","getFolderId","getFormattedFiles","uploadChildFolders","folderAPI","reject","create"],"mappings":";;;;;;;;;;;;;;;;AAAA;;;;;AAKA,OAAOA,IAAP,MAAiB,aAAjB;AACA,SAASC,gBAAT,QAAiC,qBAAjC;AACA,OAAOC,SAAP,MAAsB,WAAtB;AACA,SACIC,eADJ,EAEIC,YAFJ,EAGIC,qCAHJ,EAIIC,2BAJJ,QAKO,iBALP;;IAaMC,gB;;;AAqBF;;;;;;;;AAQA,4BACIC,KADJ,EAEIC,qBAFJ,EAGIC,sBAHJ,EAIIC,cAJJ,EAKIC,cALJ,EAMIC,MANJ,EAOE;AAAA;;AAAA;;AAAA,mCAjCmB,EAiCnB;;AAAA,qCA7BgB,EA6BhB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,8BAqCmB,iBAAOC,aAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AACjB;AACMC,gBAAAA,OAFW,GAEwBC,MAAM,CAACC,MAAP,CAAc,KAAI,CAACF,OAAnB,CAFxB;AAGXG,gBAAAA,QAHW,GAGAH,OAAO,CAACI,GAAR,CAAY,UAAAC,MAAM;AAAA,yBAAIA,MAAM,CAACC,MAAP,CAAc,KAAI,CAACC,QAAnB,EAA6BR,aAA7B,CAAJ;AAAA,iBAAlB,CAHA;AAAA;AAAA,uBAKXS,OAAO,CAACC,GAAR,CAAYN,QAAZ,CALW;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OArCnB;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,8BAqDsB,kBAAOJ,aAAP,EAAgCW,MAAhC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBACd,KAAI,CAACC,2BAAL,EADc;;AAAA;AAGhBC,gBAAAA,gBAHgB,GAGG,KAHH;AAIhBC,gBAAAA,SAJgB,GAIJ,EAJI;AAAA;AAAA;AAAA,uBAMG,KAAI,CAACC,YAAL,EANH;;AAAA;AAMVC,gBAAAA,IANU;AAOhB,gBAAA,KAAI,CAACR,QAAL,GAAgBQ,IAAI,CAACC,EAArB;AAPgB;AAAA;;AAAA;AAAA;AAAA;;AAShB;AACA,oBAAI,aAAMC,IAAN,KAAe1B,2BAAnB,EAAgD;AAC5C,kBAAA,KAAI,CAACgB,QAAL,GAAgB,aAAMW,YAAN,CAAmBC,SAAnB,CAA6B,CAA7B,EAAgCH,EAAhD;AACH,iBAFD,MAEO,IAAIN,MAAJ,EAAY;AACfX,kBAAAA,aAAa,cAAb;AACH,iBAFM,MAEA;AACH;AACA;AACA;AACA;AACAa,kBAAAA,gBAAgB,GAAG,IAAnB;AACAC,kBAAAA,SAAS,GAAG,aAAMI,IAAlB;AACAlB,kBAAAA,aAAa,CAAC;AAAEkB,oBAAAA,IAAI,EAAE3B;AAAR,mBAAD,CAAb;AACH;;AAtBe;AAAA,qBA0BhBoB,MA1BgB;AAAA;AAAA;AAAA;;AAAA;;AAAA;AA8BdU,gBAAAA,YA9Bc,GA8BmB;AACnCC,kBAAAA,SAAS,EAAE,EADwB;AAEnC5B,kBAAAA,IAAI,EAAE,KAAI,CAACA,IAFwB;AAGnC6B,kBAAAA,MAAM,EAAElC,eAH2B;AAInCmC,kBAAAA,QAAQ,EAAE,IAJyB;AAKnCC,kBAAAA,IAAI,EAAE,CAL6B;AAMnCC,kBAAAA,QAAQ,EAAE;AANyB,iBA9BnB;;AAuCpB,oBAAIb,gBAAJ,EAAsB;AAClBQ,kBAAAA,YAAY,CAACE,MAAb,GAAsBjC,YAAtB;AACA+B,kBAAAA,YAAY,CAACM,KAAb,GAAqB;AAAET,oBAAAA,IAAI,EAAEJ;AAAR,mBAArB;AACH;;AAED,gBAAA,KAAI,CAAClB,sBAAL,CAA4ByB,YAA5B;;AA5CoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OArDtB;;AAAA;AAAA;AAAA;AAAA;;AAAA,+CA0GkB;AAAA,aAChB,KAAI,CAACO,KAAL,CAAWvB,GAAX,CAAe,UAACwB,IAAD;AAAA,eAAiB;AAC5BA,UAAAA,IAAI,EAAJA,IAD4B;AAE5BC,UAAAA,OAAO,oBACA,KAAI,CAACjC,cADL;AAEHW,YAAAA,QAAQ,EAAE,KAAI,CAACA,QAFZ;AAGHuB,YAAAA,mBAAmB,EAAEC,IAAI,CAACC,GAAL;AAHlB;AAFqB,SAAjB;AAAA,OAAf,CADgB;AAAA,KA1GlB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,8BA2ImC,kBAAOC,OAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAC3BzB,OAAO,CAACC,GAAR,CACFwB,OAAO,CAAC7B,GAAR;AAAA;AAAA;AAAA;AAAA;AAAA,0CAAY,kBAAMN,KAAN;AAAA;AAAA;AAAA;AAAA;AAAA;AACAoC,4BAAAA,MADA,GACiBpC,KADjB,CACAoC,MADA,EACQzC,IADR,GACiBK,KADjB,CACQL,IADR;;AAAA,iCAGJyC,MAHI;AAAA;AAAA;AAAA;;AAAA;AAAA,mCAIehD,gBAAgB,CAACY,KAAD,CAJ/B;;AAAA;AAIE8B,4BAAAA,IAJF;;AAKJ,4BAAA,KAAI,CAACD,KAAL,CAAWQ,IAAX,CAAgBP,IAAhB;;AALI;;AAAA;AASR,4BAAA,KAAI,CAAC5B,OAAL,CAAaP,IAAb,IAAqB,IAAID,gBAAJ,CACjBC,IADiB,EAEjB,KAAI,CAACC,qBAFY,EAGjB,KAAI,CAACC,sBAHY,EAIjB,KAAI,CAACC,cAJY,oBAMV,KAAI,CAACC,cANK,MAOV,KAAI,CAACD,cAPK,GASjBE,KATiB,CAArB;;AATQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAZ;;AAAA;AAAA;AAAA;AAAA,oBADE,CAD2B;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OA3InC;;AAAA;AAAA;AAAA;AAAA;;AAAA,uCA6KU,UAACsC,MAAD,EAA0BC,OAA1B,EAAgD;AACxDD,MAAAA,MAAM,CAACE,WAAP;AAAA;AAAA;AAAA;AAAA;AAAA,gCAAmB,kBAAML,OAAN;AAAA;AAAA;AAAA;AAAA;AAAA,sBAEVA,OAAO,CAACM,MAFE;AAAA;AAAA;AAAA;;AAGXF,kBAAAA,OAAO;AAHI;;AAAA;AAAA;AAAA,yBAOT,KAAI,CAACG,kCAAL,CAAwCP,OAAxC,CAPS;;AAAA;AASf,kBAAA,KAAI,CAACQ,SAAL,CAAeL,MAAf,EAAuBC,OAAvB;;AATe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAnB;;AAAA;AAAA;AAAA;AAAA,WAUGpD,IAVH;AAWH,KAzLC;;AAAA,yDAiM4B,YAAoB;AAC9C,UAAI,CAAC,KAAI,CAACa,KAAV,EAAiB;AACb,eAAOU,OAAO,CAAC6B,OAAR,EAAP;AACH;;AAED,aAAO,IAAI7B,OAAJ,CAAY,UAAA6B,OAAO,EAAI;AAC1B;AACA,YAAMD,MAAM,GAAG,KAAI,CAACtC,KAAL,CAAW4C,YAAX,EAAf;;AAEA,QAAA,KAAI,CAACD,SAAL,CAAeL,MAAf,EAAuBC,OAAvB;AACH,OALM,CAAP;AAMH,KA5MC;;AAAA,yCAkNY,YAAc;AACxB,aAAO,KAAI,CAAC9B,QAAZ;AACH,KApNC;;AACE,SAAKd,IAAL,GAAYA,KAAZ;AACA,SAAKC,qBAAL,GAA6BA,qBAA7B;AACA,SAAKC,sBAAL,GAA8BA,sBAA9B;AACA,SAAKC,cAAL,GAAsBA,cAAtB;AACA,SAAKC,cAAL,GAAsBA,cAAtB;AACA,SAAKC,KAAL,GAAaA,MAAb;AACH;AAED;;;;;;;;;;;;;;;;gDASa6C,c,EAAwB5C,a;;;;;;;AAAyBW,gBAAAA,M,8DAAkB,K;AAC5E,qBAAKiC,cAAL,GAAsBA,cAAtB;;uBAEM,KAAKC,qBAAL,CAA2B7C,aAA3B,EAA0CW,MAA1C,C;;;qBAGF,KAAKmC,WAAL,E;;;;;AACA,qBAAKnD,qBAAL,CAA2B,KAAKoD,iBAAL,EAA3B,EAAqD7D,IAArD,EAA2D,IAA3D;;uBACM,KAAK8D,kBAAL,CAAwBhD,aAAxB,C;;;;;;;;;;;;;;;;AAId;;;;;;;;;;;AAsFA;;;;;;mCAM6B;AAAA;;AACzB,UAAMiD,SAAS,GAAG,IAAI7D,SAAJ,mBACX,KAAKU,cADM;AAEdmB,QAAAA,EAAE,mBAAY,KAAK2B,cAAjB;AAFY,SAAlB;AAIA,aAAO,IAAInC,OAAJ,CAAY,UAAC6B,OAAD,EAAUY,MAAV,EAAqB;AACpCD,QAAAA,SAAS,CAACE,MAAV,CAAiB,MAAI,CAACP,cAAtB,EAAsC,MAAI,CAAClD,IAA3C,EAAiD4C,OAAjD,EAA0DY,MAA1D;AACH,OAFM,CAAP;AAGH;AAED;;;;;;;;;;;;;AAmFJ,eAAezD,gBAAf","sourcesContent":["/**\n * @flow\n * @file Recursively create folder and upload files\n * @author Box\n */\nimport noop from 'lodash/noop';\nimport { getFileFromEntry } from '../../utils/uploads';\nimport FolderAPI from '../Folder';\nimport {\n    STATUS_COMPLETE,\n    STATUS_ERROR,\n    ERROR_CODE_UPLOAD_CHILD_FOLDER_FAILED,\n    ERROR_CODE_ITEM_NAME_IN_USE,\n} from '../../constants';\nimport type {\n    UploadFileWithAPIOptions,\n    FileSystemFileEntry,\n    FolderUploadItem,\n    DirectoryReader,\n} from '../../common/types/upload';\n\nclass FolderUploadNode {\n    addFolderToUploadQueue: Function;\n\n    files: Array<File> = [];\n\n    folderId: string;\n\n    folders: Object = {};\n\n    name: string;\n\n    parentFolderId: string;\n\n    addFilesToUploadQueue: Function;\n\n    fileAPIOptions: Object;\n\n    baseAPIOptions: Object;\n\n    entry: ?FileSystemFileEntry;\n\n    /**\n     * [constructor]\n     *\n     * @param {string} name\n     * @param {Function} addFilesToUploadQueue\n     * @param {Function} addFolderToUploadQueue\n     * @returns {void}\n     */\n    constructor(\n        name: string,\n        addFilesToUploadQueue: Function,\n        addFolderToUploadQueue: Function,\n        fileAPIOptions: Object,\n        baseAPIOptions: Object,\n        entry?: FileSystemFileEntry,\n    ) {\n        this.name = name;\n        this.addFilesToUploadQueue = addFilesToUploadQueue;\n        this.addFolderToUploadQueue = addFolderToUploadQueue;\n        this.fileAPIOptions = fileAPIOptions;\n        this.baseAPIOptions = baseAPIOptions;\n        this.entry = entry;\n    }\n\n    /**\n     * Upload a folder\n     *\n     * @public\n     * @param {string} parentFolderId\n     * @param {Function} errorCallback\n     * @param {boolean} isRoot\n     * @returns {Promise}\n     */\n    async upload(parentFolderId: string, errorCallback: Function, isRoot: boolean = false) {\n        this.parentFolderId = parentFolderId;\n\n        await this.createAndUploadFolder(errorCallback, isRoot);\n\n        // Check if folder was successfully created before we attempt to upload its contents.\n        if (this.getFolderId()) {\n            this.addFilesToUploadQueue(this.getFormattedFiles(), noop, true);\n            await this.uploadChildFolders(errorCallback);\n        }\n    }\n\n    /**\n     * Upload all child folders\n     *\n     * @private\n     * @param {Function} errorCallback\n     * @returns {Promise}\n     */\n    uploadChildFolders = async (errorCallback: Function) => {\n        // $FlowFixMe\n        const folders: Array<FolderUploadNode> = Object.values(this.folders);\n        const promises = folders.map(folder => folder.upload(this.folderId, errorCallback));\n\n        await Promise.all(promises);\n    };\n\n    /**\n     * Create folder and add it to the upload queue\n     *\n     * @private\n     * @param {Function} errorCallback\n     * @param {boolean} isRoot\n     * @returns {Promise}\n     */\n    createAndUploadFolder = async (errorCallback: Function, isRoot: boolean) => {\n        await this.buildCurrentFolderFromEntry();\n\n        let errorEncountered = false;\n        let errorCode = '';\n        try {\n            const data = await this.createFolder();\n            this.folderId = data.id;\n        } catch (error) {\n            // @TODO: Handle 429\n            if (error.code === ERROR_CODE_ITEM_NAME_IN_USE) {\n                this.folderId = error.context_info.conflicts[0].id;\n            } else if (isRoot) {\n                errorCallback(error);\n            } else {\n                // If this is a child folder of the folder being uploaded, this errorCallback will set\n                // an error message on the root folder being uploaded. Set a generic messages saying that a\n                // child has caused the error. The child folder will be tagged with the error message in\n                // the call to this.addFolderToUploadQueue below\n                errorEncountered = true;\n                errorCode = error.code;\n                errorCallback({ code: ERROR_CODE_UPLOAD_CHILD_FOLDER_FAILED });\n            }\n        }\n\n        // The root folder has already been added to the upload queue in ContentUploader\n        if (isRoot) {\n            return;\n        }\n\n        const folderObject: FolderUploadItem = {\n            extension: '',\n            name: this.name,\n            status: STATUS_COMPLETE,\n            isFolder: true,\n            size: 1,\n            progress: 100,\n        };\n\n        if (errorEncountered) {\n            folderObject.status = STATUS_ERROR;\n            folderObject.error = { code: errorCode };\n        }\n\n        this.addFolderToUploadQueue(folderObject);\n    };\n\n    /**\n     * Format files to Array<UploadFileWithAPIOptions> for upload\n     *\n     * @private\n     * @returns {Array<UploadFileWithAPIOptions>}\n     */\n    getFormattedFiles = (): Array<UploadFileWithAPIOptions> =>\n        this.files.map((file: File) => ({\n            file,\n            options: {\n                ...this.fileAPIOptions,\n                folderId: this.folderId,\n                uploadInitTimestamp: Date.now(),\n            },\n        }));\n\n    /**\n     * Promisify create folder\n     *\n     * @private\n     * @returns {Promise}\n     */\n    createFolder(): Promise<any> {\n        const folderAPI = new FolderAPI({\n            ...this.baseAPIOptions,\n            id: `folder_${this.parentFolderId}`,\n        });\n        return new Promise((resolve, reject) => {\n            folderAPI.create(this.parentFolderId, this.name, resolve, reject);\n        });\n    }\n\n    /**\n     * Create FolderUploadNode instances from entries\n     *\n     * @private\n     * @param {Array<FileSystemFileEntry>} entries\n     * @returns {Promise<any>}\n     */\n    createFolderUploadNodesFromEntries = async (entries: Array<FileSystemFileEntry>): Promise<any> => {\n        await Promise.all(\n            entries.map(async entry => {\n                const { isFile, name } = entry;\n\n                if (isFile) {\n                    const file = await getFileFromEntry(entry);\n                    this.files.push(file);\n                    return;\n                }\n\n                this.folders[name] = new FolderUploadNode(\n                    name,\n                    this.addFilesToUploadQueue,\n                    this.addFolderToUploadQueue,\n                    this.fileAPIOptions,\n                    {\n                        ...this.baseAPIOptions,\n                        ...this.fileAPIOptions,\n                    },\n                    entry,\n                );\n            }),\n        );\n    };\n\n    /**\n     * Recursively read an entry\n     *\n     * @private\n     * @param {DirectoryReader} reader\n     * @param {Function} resolve\n     * @returns {void}\n     */\n    readEntry = (reader: DirectoryReader, resolve: Function) => {\n        reader.readEntries(async entries => {\n            // Quit recursing when there are no remaining entries.\n            if (!entries.length) {\n                resolve();\n                return;\n            }\n\n            await this.createFolderUploadNodesFromEntries(entries);\n\n            this.readEntry(reader, resolve);\n        }, noop);\n    };\n\n    /**\n     * Build current folder from entry\n     *\n     * @private\n     * @returns {Promise<any>}\n     */\n    buildCurrentFolderFromEntry = (): Promise<any> => {\n        if (!this.entry) {\n            return Promise.resolve();\n        }\n\n        return new Promise(resolve => {\n            // $FlowFixMe entry is not empty\n            const reader = this.entry.createReader();\n\n            this.readEntry(reader, resolve);\n        });\n    };\n\n    /**\n     * Returns the folderId\n     * @returns {string}\n     */\n    getFolderId = (): string => {\n        return this.folderId;\n    };\n}\n\nexport default FolderUploadNode;\n"],"file":"FolderUploadNode.js"}