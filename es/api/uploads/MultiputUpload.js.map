{"version":3,"sources":["../../../src/api/uploads/MultiputUpload.js"],"names":["noop","isNaN","getFileLastModifiedAsISONoMSIfPossible","getBoundedExpBackoffRetryDelay","retryNumOfTimes","digest","hexToBase64","createWorker","Browser","DEFAULT_RETRY_DELAY_MS","ERROR_CODE_UPLOAD_STORAGE_LIMIT_EXCEEDED","HTTP_STATUS_CODE_FORBIDDEN","MS_IN_S","MultiputPart","PART_STATE_UPLOADED","PART_STATE_UPLOADING","PART_STATE_DIGEST_READY","PART_STATE_NOT_STARTED","BaseMultiput","LOG_EVENT_TYPE_CREATE_SESSION_MISC_ERROR","LOG_EVENT_TYPE_CREATE_SESSION_RETRIES_EXCEEDED","LOG_EVENT_TYPE_FILE_CHANGED_DURING_UPLOAD","LOG_EVENT_TYPE_PART_UPLOAD_RETRIES_EXCEEDED","LOG_EVENT_TYPE_COMMIT_RETRIES_EXCEEDED","LOG_EVENT_TYPE_WEB_WORKER_ERROR","LOG_EVENT_TYPE_FILE_READER_RECEIVED_NOT_FOUND_ERROR","LOG_EVENT_TYPE_PART_DIGEST_RETRIES_EXCEEDED","MultiputUpload","options","config","createSession","uploadPart","listParts","commit","abort","logEvent","data","upload_url","getBaseUploadUrl","splitUrl","split","uploadHost","preflightResponse","isDestroyed","uploadUrl","getBaseUploadUrlFromPreflightResponse","createSessionUrl","includes","parallelism","postData","file_size","file","size","file_name","fileName","fileId","replace","folder_id","folderId","xhr","post","url","response","createSessionSuccessHandler","errorData","getErrorResponse","status","createSessionErrorHandler","code","context_info","session","errorCallback","resolveConflict","createSessionRetry","sessionErrorHandler","JSON","stringify","error","createSessionNumRetriesPerformed","retries","consoleLog","sessionUrl","sessionId","get","getSessionSuccessHandler","getSessionErrorHandler","part","numPartsUploading","numPartsUploaded","updateProgress","uploadedBytes","partSize","processNextParts","eventInfo","isResumableUploadsEnabled","nextUploadIndex","firstUnuploadedPartIndex","parts","state","reset","pause","numPartsDigestReady","prevUploadedBytes","newUploadedBytes","totalUploadedBytes","progressCallback","loaded","total","failSessionIfFileChangeDetected","length","fileSha1","commitSession","updateFirstUnuploadedPartIndex","canStartMorePartUploads","uploadNextPart","shouldComputeDigestForNextPart","computeDigestForNextPart","event","type","numPartsDigestComputing","index","timing","fileDigestTime","duration","sha1","sha1Worker","terminate","buffer","partInformation","offset","postMessage","fileSize","partContents","name","numDigestRetriesPerformed","retryDelayMs","initialRetryDelayMs","maxRetryDelayMs","setTimeout","computeDigestForPart","stats","totalPartReadTime","totalPartDigestTime","totalFileDigestTime","totalPartUploadTime","map","readTime","subtleCryptoTime","uploadTime","getPart","sort","part1","part2","attributes","fileLastModified","content_modified_at","fileDescription","description","clientEventInfo","avg_part_read_time","Math","round","avg_part_digest_time","avg_file_digest_time","avg_part_upload_time","headers","Digest","sessionEndpoints","then","commitSessionSuccessHandler","catch","commitSessionErrorHandler","commitSessionRetry","entries","id","destroy","successCallback","consoleError","commitRetryCount","numPartsNotStarted","clientId","numResumeRetries","overwrite","conflictCallback","initialFileSize","initialFileLastModified","addEventListener","onWorkerMessage","makePreflightRequest","createSessionTimeout","part_size","session_endpoints","upload_part","list_parts","log_event","populateParts","setFileInfo","getSessionInfo","retryAfterMs","retryAfterSec","parseInt","retryTimeout","forEach","cancel","clearTimeout","commitSessionTimeout","abortSession","uploadOptions","upload","logEventType","logMessage","Error","resolve","reject","delete","digestReadahead","i","blob","slice","reader","window","FileReader","startTimestamp","Date","now","readFile","readCompleteTimestamp","sha256ArrayBuffer","sha256","btoa","reduce","call","Uint8Array","byte","String","fromCharCode","sendPartToWorker","digestCompleteTimestamp","partDigestTime","onPartDigestError","Number","defaultRetryDelayMs","isPaused","unpause","ceil","currentPartSize","min","getNumPartsUploading","partUploadSuccessHandler","partUploadErrorHandler","push","currentFileSize","currentFileLastModified","changeJSON","oldSize","newSize","oldLastModified","newLastModified","isIE","conflicts","extension","substr","lastIndexOf"],"mappings":"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","sourcesContent":["/**\n * @flow\n * @file Multiput upload\n * @author Box\n */\n\nimport noop from 'lodash/noop';\nimport isNaN from 'lodash/isNaN';\nimport { getFileLastModifiedAsISONoMSIfPossible, getBoundedExpBackoffRetryDelay } from '../../utils/uploads';\nimport { retryNumOfTimes } from '../../utils/function';\nimport { digest } from '../../utils/webcrypto';\nimport hexToBase64 from '../../utils/base64';\nimport createWorker from '../../utils/uploadsSHA1Worker';\nimport Browser from '../../utils/Browser';\nimport {\n    DEFAULT_RETRY_DELAY_MS,\n    ERROR_CODE_UPLOAD_STORAGE_LIMIT_EXCEEDED,\n    HTTP_STATUS_CODE_FORBIDDEN,\n    MS_IN_S,\n} from '../../constants';\nimport MultiputPart, {\n    PART_STATE_UPLOADED,\n    PART_STATE_UPLOADING,\n    PART_STATE_DIGEST_READY,\n    PART_STATE_NOT_STARTED,\n} from './MultiputPart';\nimport BaseMultiput from './BaseMultiput';\nimport type { MultiputConfig } from '../../common/types/upload';\nimport type { StringAnyMap } from '../../common/types/core';\nimport type { APIOptions } from '../../common/types/api';\n\n// Constants used for specifying log event types.\n\n// This type is a catch-all for create session errors that aren't 5xx's (for which we'll do\n// retries) and aren't specific 4xx's we know how to specifically handle (e.g. out of storage).\nconst LOG_EVENT_TYPE_CREATE_SESSION_MISC_ERROR = 'create_session_misc_error';\nconst LOG_EVENT_TYPE_CREATE_SESSION_RETRIES_EXCEEDED = 'create_session_retries_exceeded';\nconst LOG_EVENT_TYPE_FILE_CHANGED_DURING_UPLOAD = 'file_changed_during_upload';\nconst LOG_EVENT_TYPE_PART_UPLOAD_RETRIES_EXCEEDED = 'part_upload_retries_exceeded';\nconst LOG_EVENT_TYPE_COMMIT_RETRIES_EXCEEDED = 'commit_retries_exceeded';\nconst LOG_EVENT_TYPE_WEB_WORKER_ERROR = 'web_worker_error';\nconst LOG_EVENT_TYPE_FILE_READER_RECEIVED_NOT_FOUND_ERROR = 'file_reader_received_not_found_error';\nconst LOG_EVENT_TYPE_PART_DIGEST_RETRIES_EXCEEDED = 'part_digest_retries_exceeded';\n\nclass MultiputUpload extends BaseMultiput {\n    clientId: ?string;\n\n    commitRetryCount: number;\n\n    createSessionNumRetriesPerformed: number;\n\n    destinationFileId: ?string;\n\n    folderId: string;\n\n    fileSha1: ?string;\n\n    firstUnuploadedPartIndex: number;\n\n    initialFileLastModified: ?string;\n\n    initialFileSize: number;\n\n    isResumableUploadsEnabled: boolean;\n\n    successCallback: Function;\n\n    progressCallback: Function;\n\n    options: APIOptions;\n\n    partSize: number;\n\n    parts: Array<MultiputPart>;\n\n    numPartsDigestComputing: number;\n\n    numPartsDigestReady: number;\n\n    numPartsNotStarted: number;\n\n    numPartsUploaded: number;\n\n    numPartsUploading: number;\n\n    numResumeRetries: number;\n\n    sessionEndpoints: Object;\n\n    sessionId: string;\n\n    totalUploadedBytes: number;\n\n    sha1Worker: Worker;\n\n    createSessionTimeout: TimeoutID;\n\n    commitSessionTimeout: TimeoutID;\n\n    /**\n     * [constructor]\n     *\n     * @param {Options} options\n     * @param {MultiputConfig} [config]\n     */\n    constructor(options: APIOptions, config?: MultiputConfig) {\n        super(\n            options,\n            {\n                createSession: null,\n                uploadPart: null,\n                listParts: null,\n                commit: null,\n                abort: null,\n                logEvent: null,\n            },\n            config,\n        );\n        this.parts = [];\n        this.options = options;\n        this.fileSha1 = null;\n        this.totalUploadedBytes = 0;\n        this.numPartsNotStarted = 0; // # of parts yet to be processed\n        this.numPartsDigestComputing = 0; // # of parts sent to the digest worker\n        this.numPartsDigestReady = 0; // # of parts with digest finished that are waiting to be uploaded.\n        this.numPartsUploading = 0; // # of parts with upload requests currently inflight\n        this.numPartsUploaded = 0; // # of parts successfully uploaded\n        this.firstUnuploadedPartIndex = 0; // Index of first part that hasn't been uploaded yet.\n        this.createSessionNumRetriesPerformed = 0;\n        this.partSize = 0;\n        this.commitRetryCount = 0;\n        this.clientId = null;\n        this.isResumableUploadsEnabled = false;\n        this.numResumeRetries = 0;\n    }\n\n    /**\n     * Reset values for uploading process.\n     */\n    reset() {\n        this.parts = [];\n        this.fileSha1 = null;\n        this.totalUploadedBytes = 0;\n        this.numPartsNotStarted = 0; // # of parts yet to be processed\n        this.numPartsDigestComputing = 0; // # of parts sent to the digest worker\n        this.numPartsDigestReady = 0; // # of parts with digest finished that are waiting to be uploaded.\n        this.numPartsUploading = 0; // # of parts with upload requests currently inflight\n        this.numPartsUploaded = 0; // # of parts successfully uploaded\n        this.firstUnuploadedPartIndex = 0; // Index of first part that hasn't been uploaded yet.\n        this.createSessionNumRetriesPerformed = 0;\n        this.partSize = 0;\n        this.commitRetryCount = 0;\n        this.numResumeRetries = 0;\n    }\n\n    /**\n     * Set information about file being uploaded\n     *\n     *\n     * @param {Object} options\n     * @param {File} options.file\n     * @param {string} options.folderId - Untyped folder id (e.g. no \"folder_\" prefix)\n     * @param {string} [options.fileId] - Untyped file id (e.g. no \"file_\" prefix)\n     * @param {string} options.sessionId\n     * @param {Function} [options.errorCallback]\n     * @param {Function} [options.progressCallback]\n     * @param {Function} [options.successCallback]\n     * @return {void}\n     */\n    setFileInfo({\n        file,\n        folderId,\n        errorCallback,\n        progressCallback,\n        successCallback,\n        overwrite = true,\n        conflictCallback,\n        fileId,\n    }: {\n        conflictCallback?: Function,\n        errorCallback?: Function,\n        file: File,\n        fileId: ?string,\n        folderId: string,\n        overwrite?: boolean,\n        progressCallback?: Function,\n        successCallback?: Function,\n    }): void {\n        this.file = file;\n        this.fileName = this.file.name;\n        this.folderId = folderId;\n        this.errorCallback = errorCallback || noop;\n        this.progressCallback = progressCallback || noop;\n        this.successCallback = successCallback || noop;\n        this.overwrite = overwrite;\n        this.conflictCallback = conflictCallback;\n        this.fileId = fileId;\n    }\n\n    /**\n     * Upload a given file\n     *\n     *\n     * @param {Object} options\n     * @param {File} options.file\n     * @param {string} options.folderId - Untyped folder id (e.g. no \"folder_\" prefix)\n     * @param {string} [options.fileId] - Untyped file id (e.g. no \"file_\" prefix)\n     * @param {Function} [options.errorCallback]\n     * @param {Function} [options.progressCallback]\n     * @param {Function} [options.successCallback]\n     * @return {void}\n     */\n    upload({\n        file,\n        fileDescription,\n        folderId,\n        errorCallback,\n        progressCallback,\n        successCallback,\n        overwrite = true,\n        conflictCallback,\n        fileId,\n    }: {\n        conflictCallback?: Function,\n        errorCallback?: Function,\n        file: File,\n        fileDescription: ?string,\n        fileId: ?string,\n        folderId: string,\n        overwrite?: boolean,\n        progressCallback?: Function,\n        successCallback?: Function,\n    }): void {\n        this.file = file;\n        this.fileName = this.file.name;\n        // These values are used as part of our (best effort) attempt to abort uploads if we detect\n        // a file change during the upload.\n        this.initialFileSize = this.file.size;\n        this.initialFileLastModified = getFileLastModifiedAsISONoMSIfPossible(this.file);\n        this.folderId = folderId;\n        this.errorCallback = errorCallback || noop;\n        this.progressCallback = progressCallback || noop;\n        this.successCallback = successCallback || noop;\n\n        this.sha1Worker = createWorker();\n        this.sha1Worker.addEventListener('message', this.onWorkerMessage);\n\n        this.conflictCallback = conflictCallback;\n        this.overwrite = overwrite;\n        this.fileId = fileId;\n        this.fileDescription = fileDescription;\n\n        this.makePreflightRequest();\n    }\n\n    /**\n     * Update uploadHost with preflight response and return the base uploadUrl\n     *\n     * @private\n     * @param {Object} response\n     * @param {Object} [response.data]\n     * @return {string}\n     */\n    getBaseUploadUrlFromPreflightResponse = ({ data }: { data: { upload_url?: string } }) => {\n        if (!data || !data.upload_url) {\n            return this.getBaseUploadUrl();\n        }\n\n        const splitUrl = data.upload_url.split('/');\n        // splitUrl[0] is the protocol (e.g., https:), splitUrl[2] is hostname (e.g., www.box.com)\n        this.uploadHost = `${splitUrl[0]}//${splitUrl[2]}`;\n        return this.getBaseUploadUrl();\n    };\n\n    /**\n     * Creates upload session. If a file ID is supplied, use the Chunked Upload File Version\n     * API to replace the file.\n     *\n     * @private\n     * @return {void}\n     */\n    preflightSuccessHandler = async (preflightResponse: Object): Promise<any> => {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        const uploadUrl = this.getBaseUploadUrlFromPreflightResponse(preflightResponse);\n        let createSessionUrl = `${uploadUrl}/files/upload_sessions`;\n\n        // Parallelism is currently detrimental to multiput upload performance in Zones, so set it to 1.\n        if (createSessionUrl.includes('fupload-ec2')) {\n            this.config.parallelism = 1;\n        }\n\n        // Set up post body\n        const postData: StringAnyMap = {\n            file_size: this.file.size,\n            file_name: this.fileName,\n        };\n\n        if (this.fileId) {\n            createSessionUrl = createSessionUrl.replace('upload_sessions', `${this.fileId}/upload_sessions`);\n        } else {\n            postData.folder_id = this.folderId;\n        }\n\n        try {\n            const response = await this.xhr.post({\n                url: createSessionUrl,\n                data: postData,\n            });\n            this.createSessionSuccessHandler(response.data);\n        } catch (error) {\n            const errorData = this.getErrorResponse(error);\n\n            if (errorData && errorData.status >= 500 && errorData.status < 600) {\n                this.createSessionErrorHandler(error);\n                return;\n            }\n\n            // Recover from 409 session_conflict.  The server will return the session information\n            // in context_info, so treat it as a success.\n            if (errorData && errorData.status === 409 && errorData.code === 'session_conflict') {\n                this.createSessionSuccessHandler(errorData.context_info.session);\n                return;\n            }\n\n            if (\n                (errorData &&\n                    errorData.status === HTTP_STATUS_CODE_FORBIDDEN &&\n                    errorData.code === ERROR_CODE_UPLOAD_STORAGE_LIMIT_EXCEEDED) ||\n                (errorData.status === HTTP_STATUS_CODE_FORBIDDEN &&\n                    errorData.code === 'access_denied_insufficient_permissions')\n            ) {\n                this.errorCallback(errorData);\n                return;\n            }\n\n            if (errorData && errorData.status === 409) {\n                this.resolveConflict(errorData);\n                this.createSessionRetry();\n                return;\n            }\n\n            // All other cases get treated as an upload failure.\n            this.sessionErrorHandler(error, LOG_EVENT_TYPE_CREATE_SESSION_MISC_ERROR, JSON.stringify(error));\n        }\n    };\n\n    /**\n     * Create session error handler.\n     * Retries the create session request or fails the upload.\n     *\n     * @private\n     * @param {Error} error\n     * @return {void}\n     */\n    createSessionErrorHandler = (error: Error): void => {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        if (this.createSessionNumRetriesPerformed < this.config.retries) {\n            this.createSessionRetry();\n            return;\n        }\n\n        this.consoleLog('Too many create session failures, failing upload');\n        this.sessionErrorHandler(error, LOG_EVENT_TYPE_CREATE_SESSION_RETRIES_EXCEEDED, JSON.stringify(error));\n    };\n\n    /**\n     * Schedule a retry for create session request upon failure\n     *\n     * @private\n     * @return {void}\n     */\n    createSessionRetry(): void {\n        const retryDelayMs = getBoundedExpBackoffRetryDelay(\n            this.config.initialRetryDelayMs,\n            this.config.maxRetryDelayMs,\n            this.createSessionNumRetriesPerformed,\n        );\n        this.createSessionNumRetriesPerformed += 1;\n        this.consoleLog(`Retrying create session in ${retryDelayMs} ms`);\n        this.createSessionTimeout = setTimeout(this.makePreflightRequest, retryDelayMs);\n    }\n\n    /**\n     * Handles a upload session success response\n     *\n     * @private\n     * @param {Object} data - Upload session creation success data\n     * @return {void}\n     */\n    createSessionSuccessHandler(data: any): void {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        const { id, part_size, session_endpoints } = data;\n\n        this.sessionId = id;\n        this.partSize = part_size;\n        this.sessionEndpoints = {\n            ...this.sessionEndpoints,\n            uploadPart: session_endpoints.upload_part,\n            listParts: session_endpoints.list_parts,\n            commit: session_endpoints.commit,\n            abort: session_endpoints.abort,\n            logEvent: session_endpoints.log_event,\n        };\n\n        this.populateParts();\n        this.processNextParts();\n    }\n\n    /**\n     * Resume uploading the given file\n     *\n     *\n     * @param {Object} options\n     * @param {File} options.file\n     * @param {string} options.folderId - Untyped folder id (e.g. no \"folder_\" prefix)\n     * @param {string} [options.fileId] - Untyped file id (e.g. no \"file_\" prefix)\n     * @param {string} options.sessionId\n     * @param {Function} [options.errorCallback]\n     * @param {Function} [options.progressCallback]\n     * @param {Function} [options.successCallback]\n     * @param {Function} [options.conflictCallback]\n     * @return {void}\n     */\n    resume({\n        file,\n        folderId,\n        errorCallback,\n        progressCallback,\n        sessionId,\n        successCallback,\n        overwrite = true,\n        conflictCallback,\n        fileId,\n    }: {\n        conflictCallback?: Function,\n        errorCallback?: Function,\n        file: File,\n        fileId: ?string,\n        folderId: string,\n        overwrite?: boolean,\n        progressCallback?: Function,\n        sessionId: string,\n        successCallback?: Function,\n    }): void {\n        this.setFileInfo({\n            file,\n            folderId,\n            errorCallback,\n            progressCallback,\n            successCallback,\n            conflictCallback,\n            overwrite,\n            fileId,\n        });\n        this.sessionId = sessionId;\n\n        if (!this.sha1Worker) {\n            this.sha1Worker = createWorker();\n        }\n        this.sha1Worker.addEventListener('message', this.onWorkerMessage);\n\n        this.getSessionInfo();\n    }\n\n    /**\n     * Get session information from API.\n     * Uses session info to commit a complete session or continue an in-progress session.\n     *\n     * @private\n     * @return {void}\n     */\n    getSessionInfo = async (): Promise<any> => {\n        const uploadUrl = this.getBaseUploadUrl();\n        const sessionUrl = `${uploadUrl}/files/upload_sessions/${this.sessionId}`;\n        try {\n            const response = await this.xhr.get({ url: sessionUrl });\n            this.getSessionSuccessHandler(response.data);\n        } catch (error) {\n            this.getSessionErrorHandler(error);\n        }\n    };\n\n    /**\n     * Handles a getSessionInfo success and either commits the session or continues to process\n     * the parts that still need to be uploaded.\n     *\n     * @param response\n     * @return {void}\n     */\n    getSessionSuccessHandler(data: any): void {\n        const { part_size, session_endpoints } = data;\n\n        // Set session information gotten from API response\n        this.partSize = part_size;\n        this.sessionEndpoints = {\n            ...this.sessionEndpoints,\n            uploadPart: session_endpoints.upload_part,\n            listParts: session_endpoints.list_parts,\n            commit: session_endpoints.commit,\n            abort: session_endpoints.abort,\n            logEvent: session_endpoints.log_event,\n        };\n\n        this.processNextParts();\n    }\n\n    /**\n     * Handle error from getting upload session.\n     * Restart uploads without valid sessions from the beginning of the upload process.\n     *\n     * @param error\n     * @return {void}\n     */\n    getSessionErrorHandler(error: Error): void {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        const errorData = this.getErrorResponse(error);\n        if (this.numResumeRetries > this.config.retries) {\n            this.errorCallback(errorData);\n            return;\n        }\n\n        if (errorData && errorData.status === 429) {\n            let retryAfterMs = DEFAULT_RETRY_DELAY_MS;\n            if (errorData.headers) {\n                const retryAfterSec = parseInt(\n                    errorData.headers['retry-after'] || errorData.headers.get('Retry-After'),\n                    10,\n                );\n                if (!isNaN(retryAfterSec)) {\n                    retryAfterMs = retryAfterSec * MS_IN_S;\n                }\n            }\n            this.retryTimeout = setTimeout(this.getSessionInfo, retryAfterMs);\n            this.numResumeRetries += 1;\n        } else if (errorData && errorData.status >= 400 && errorData.status < 500) {\n            // Restart upload process for errors resulting from invalid/expired session or no permission\n            this.parts.forEach(part => {\n                part.cancel();\n            });\n            this.reset();\n\n            // Abort session\n            clearTimeout(this.createSessionTimeout);\n            clearTimeout(this.commitSessionTimeout);\n            this.abortSession();\n            // Restart the uploading process from the beginning\n            const uploadOptions: Object = {\n                file: this.file,\n                folderId: this.folderId,\n                errorCallback: this.errorCallback,\n                progressCallback: this.progressCallback,\n                successCallback: this.successCallback,\n                overwrite: this.overwrite,\n                fileId: this.fileId,\n            };\n            this.upload(uploadOptions);\n        } else {\n            // Handle internet disconnects (error.request && !error.response) and (!error.request)\n            // Also handle any 500 error messages\n            this.retryTimeout = setTimeout(this.getSessionInfo, 2 ** this.numResumeRetries * MS_IN_S);\n            this.numResumeRetries += 1;\n        }\n    }\n\n    /**\n     * Session error handler.\n     * Retries the create session request or fails the upload.\n     *\n     * @private\n     * @param {?Error} error\n     * @param {string} logEventType\n     * @param {string} [logMessage]\n     * @return {Promise}\n     */\n    async sessionErrorHandler(error: ?Error, logEventType: string, logMessage?: string): Promise<any> {\n        if (!this.isResumableUploadsEnabled) {\n            this.destroy();\n        }\n        const errorData = this.getErrorResponse(error);\n        this.errorCallback(errorData);\n\n        try {\n            if (!this.sessionEndpoints.logEvent) {\n                throw new Error('logEvent endpoint not found');\n            }\n\n            await retryNumOfTimes(\n                (resolve: Function, reject: Function): void => {\n                    this.logEvent(logEventType, logMessage)\n                        .then(resolve)\n                        .catch(reject);\n                },\n                this.config.retries,\n                this.config.initialRetryDelayMs,\n            );\n            if (!this.isResumableUploadsEnabled) {\n                this.abortSession();\n            }\n        } catch (err) {\n            if (!this.isResumableUploadsEnabled) {\n                this.abortSession();\n            }\n        }\n    }\n\n    /**\n     * Aborts the upload session\n     *\n     * @private\n     * @return {void}\n     */\n    abortSession(): void {\n        if (this.sha1Worker) {\n            this.sha1Worker.terminate();\n        }\n\n        if (this.sessionEndpoints.abort && this.sessionId) {\n            this.xhr\n                .delete({\n                    url: this.sessionEndpoints.abort,\n                })\n                .then(() => {\n                    this.sessionId = '';\n                });\n        }\n    }\n\n    /**\n     * Part upload success handler\n     *\n     * @private\n     * @param {MultiputPart} part\n     * @return {void}\n     */\n    partUploadSuccessHandler = (part: MultiputPart): void => {\n        this.numPartsUploading -= 1;\n        this.numPartsUploaded += 1;\n        this.updateProgress(part.uploadedBytes, this.partSize);\n        this.processNextParts();\n    };\n\n    /**\n     * Part upload error handler\n     *\n     * @private\n     * @param {Error} error\n     * @param {string} eventInfo\n     * @return {void}\n     */\n    partUploadErrorHandler = (error: Error, eventInfo: string): void => {\n        this.sessionErrorHandler(error, LOG_EVENT_TYPE_PART_UPLOAD_RETRIES_EXCEEDED, eventInfo);\n        // Pause the rest of the parts.\n        // can't cancel parts because cancel destroys the part and parts are only created in createSession call\n        if (this.isResumableUploadsEnabled) {\n            // Reset uploading process for parts that were in progress when the upload failed\n            let nextUploadIndex = this.firstUnuploadedPartIndex;\n            while (this.numPartsUploading > 0) {\n                const part = this.parts[nextUploadIndex];\n                if (part && part.state === PART_STATE_UPLOADING) {\n                    part.reset();\n                    part.pause();\n\n                    this.numPartsUploading -= 1;\n                    this.numPartsDigestReady += 1;\n                }\n                nextUploadIndex += 1;\n            }\n        }\n    };\n\n    /**\n     * Update upload progress\n     *\n     * @private\n     * @param {number} prevUploadedBytes\n     * @param {number} newUploadedBytes\n     * @return {void}\n     */\n    updateProgress = (prevUploadedBytes: number, newUploadedBytes: number): void => {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        this.totalUploadedBytes += newUploadedBytes - prevUploadedBytes;\n        this.progressCallback({\n            loaded: this.totalUploadedBytes,\n            total: this.file.size,\n        });\n    };\n\n    /**\n     * Attempts to process more parts, except in the case where everything is done or we detect\n     * a file change (in which case we want to abort and not process more parts).\n     *\n     * @private\n     * @return {void}\n     */\n    processNextParts = (): void => {\n        if (this.failSessionIfFileChangeDetected()) {\n            return;\n        }\n\n        if (this.numPartsUploaded === this.parts.length && this.fileSha1) {\n            this.commitSession();\n            return;\n        }\n\n        this.updateFirstUnuploadedPartIndex();\n\n        while (this.canStartMorePartUploads()) {\n            this.uploadNextPart();\n        }\n\n        if (this.shouldComputeDigestForNextPart()) {\n            this.computeDigestForNextPart();\n        }\n    };\n\n    /**\n     * We compute digest for parts one at a time.  This is done for simplicity and also to guarantee that\n     * we send parts in order to the web sha1Worker (which is computing the digest for the entire file).\n     *\n     * @private\n     * @return {boolean} true if there is work to do, false otherwise.\n     */\n    shouldComputeDigestForNextPart(): boolean {\n        return (\n            !this.isDestroyed() &&\n            this.numPartsDigestComputing === 0 &&\n            this.numPartsNotStarted > 0 &&\n            this.numPartsDigestReady < this.config.digestReadahead\n        );\n    }\n\n    /**\n     * Find first part in parts array that doesn't have a digest, and compute its digest.\n\n     * @private\n     * @return {void}\n     */\n    computeDigestForNextPart(): void {\n        for (let i = this.firstUnuploadedPartIndex; i < this.parts.length; i += 1) {\n            const part = this.parts[i];\n            if (part.state === PART_STATE_NOT_STARTED) {\n                // Update the counters here instead of computeDigestForPart because computeDigestForPart\n                // can get called on retries\n                this.numPartsNotStarted -= 1;\n                this.numPartsDigestComputing += 1;\n                this.computeDigestForPart(part);\n                return;\n            }\n        }\n    }\n\n    /**\n     * Compute digest for this part\n     *\n     * @private\n     * @param {MultiputPart} part\n     * @return {Promise}\n     */\n    async computeDigestForPart(part: MultiputPart): Promise<any> {\n        const blob = this.file.slice(part.offset, part.offset + this.partSize);\n        const reader = new window.FileReader();\n        const startTimestamp = Date.now();\n\n        try {\n            const {\n                buffer,\n                readCompleteTimestamp,\n            }: {\n                buffer: ArrayBuffer,\n                readCompleteTimestamp: number,\n            } = await this.readFile(reader, blob);\n            const sha256ArrayBuffer = await digest('SHA-256', buffer);\n            const sha256 = btoa(\n                [].reduce.call(new Uint8Array(sha256ArrayBuffer), (data, byte) => data + String.fromCharCode(byte), ''),\n            );\n            this.sendPartToWorker(part, buffer);\n\n            part.sha256 = sha256;\n            part.state = PART_STATE_DIGEST_READY;\n            part.blob = blob;\n\n            this.numPartsDigestReady += 1;\n            const digestCompleteTimestamp = Date.now();\n\n            part.timing = {\n                partDigestTime: digestCompleteTimestamp - startTimestamp,\n                readTime: readCompleteTimestamp - startTimestamp,\n                subtleCryptoTime: digestCompleteTimestamp - readCompleteTimestamp,\n            };\n\n            this.processNextParts();\n        } catch (error) {\n            this.onPartDigestError(error, part);\n        }\n    }\n\n    /**\n     * Deal with a message from the worker (either a part sha-1 ready, file sha-1 ready, or error).\n     *\n     * @private\n     * @param {object} event\n     * @return {void}\n     */\n    onWorkerMessage = (event: Object) => {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        const { data } = event;\n        if (data.type === 'partDone') {\n            this.numPartsDigestComputing -= 1;\n            const { part } = data;\n            this.parts[part.index].timing.fileDigestTime = data.duration;\n            this.processNextParts();\n        } else if (data.type === 'done') {\n            this.fileSha1 = hexToBase64(data.sha1);\n            this.sha1Worker.terminate();\n            this.processNextParts();\n        } else if (data.type === 'error') {\n            this.sessionErrorHandler(null, LOG_EVENT_TYPE_WEB_WORKER_ERROR, JSON.stringify(data));\n        }\n    };\n\n    /**\n     * Sends a part to the sha1Worker\n     *\n     * @private\n     * @param {MultiputPart} part\n     * @param {ArrayBuffer} buffer\n     * @return {void}\n     */\n    sendPartToWorker = (part: MultiputPart, buffer: ArrayBuffer): void => {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        // Don't send entire part since XHR can't be cloned\n        const partInformation = {\n            index: part.index,\n            offset: part.offset,\n            size: part.partSize,\n        };\n        this.sha1Worker.postMessage(\n            {\n                part: partInformation,\n                fileSize: this.file.size,\n                partContents: buffer,\n            },\n            [buffer], // This transfers the ArrayBuffer to the worker context without copying contents.\n        );\n        this.consoleLog(`Part sent to worker: ${JSON.stringify(part)}.}`);\n    };\n\n    /**\n     * Error handler for part digest computation\n     *\n     * @private\n     * @param {Error} error\n     * @param {MultiputPart} part\n     * @return {void}\n     */\n    onPartDigestError = (error: Error, part: MultiputPart): void => {\n        this.consoleLog(`Error computing digest for part ${JSON.stringify(part)}: ${JSON.stringify(error)}`);\n\n        // When a FileReader is processing a file that changes on disk, Chrome reports a 'NotFoundError'\n        // and Safari reports a 'NOT_FOUND_ERR'. (Other browsers seem to allow the reader to keep\n        // going, either with the old version of the new file or the new one.) Since the error name\n        // implies that retrying will not help, we fail the session.\n        if (error.name === 'NotFoundError' || error.name === 'NOT_FOUND_ERR') {\n            this.sessionErrorHandler(null, LOG_EVENT_TYPE_FILE_READER_RECEIVED_NOT_FOUND_ERROR, JSON.stringify(error));\n            return;\n        }\n\n        if (this.failSessionIfFileChangeDetected()) {\n            return;\n        }\n\n        if (part.numDigestRetriesPerformed >= this.config.retries) {\n            this.sessionErrorHandler(null, LOG_EVENT_TYPE_PART_DIGEST_RETRIES_EXCEEDED, JSON.stringify(error));\n            return;\n        }\n\n        const retryDelayMs = getBoundedExpBackoffRetryDelay(\n            this.config.initialRetryDelayMs,\n            this.config.maxRetryDelayMs,\n            part.numDigestRetriesPerformed,\n        );\n        part.numDigestRetriesPerformed += 1;\n        this.consoleLog(`Retrying digest work for part ${JSON.stringify(part)} in ${retryDelayMs} ms`);\n\n        setTimeout(() => {\n            this.computeDigestForPart(part);\n        }, retryDelayMs);\n    };\n\n    /**\n     * Send a request to commit the upload.\n     *\n     * @private\n     * @return {void}\n     */\n    commitSession = (): void => {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        const stats = {\n            totalPartReadTime: 0,\n            totalPartDigestTime: 0,\n            totalFileDigestTime: 0,\n            totalPartUploadTime: 0,\n        };\n\n        const data = {\n            parts: this.parts\n                .map(part => {\n                    stats.totalPartReadTime += part.timing.readTime;\n                    stats.totalPartDigestTime += part.timing.subtleCryptoTime;\n                    stats.totalFileDigestTime += part.timing.fileDigestTime;\n                    stats.totalPartUploadTime += part.timing.uploadTime;\n                    return part.getPart();\n                })\n                .sort((part1, part2) => part1.offset - part2.offset),\n            attributes: {},\n        };\n\n        const fileLastModified = getFileLastModifiedAsISONoMSIfPossible(this.file);\n        if (fileLastModified) {\n            data.attributes.content_modified_at = fileLastModified;\n        }\n        if (this.fileDescription) {\n            data.attributes.description = this.fileDescription;\n        }\n\n        const clientEventInfo = {\n            avg_part_read_time: Math.round(stats.totalPartReadTime / this.parts.length),\n            avg_part_digest_time: Math.round(stats.totalPartDigestTime / this.parts.length),\n            avg_file_digest_time: Math.round(stats.totalFileDigestTime / this.parts.length),\n            avg_part_upload_time: Math.round(stats.totalPartUploadTime / this.parts.length),\n        };\n\n        // To make flow stop complaining about this.fileSha1 could potentially be undefined/null\n        const fileSha1: string = (this.fileSha1: any);\n        const headers = {\n            Digest: `sha=${fileSha1}`,\n            'X-Box-Client-Event-Info': JSON.stringify(clientEventInfo),\n        };\n\n        this.xhr\n            .post({ url: this.sessionEndpoints.commit, data, headers })\n            .then(this.commitSessionSuccessHandler)\n            .catch(this.commitSessionErrorHandler);\n    };\n\n    /**\n     * Commit response handler.  Succeeds the upload, retries the commit on 202\n     *\n     * @private\n     * @param {Object} response\n     * @return {void}\n     */\n    commitSessionSuccessHandler = (response: Object): void => {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        const { status, data } = response;\n\n        if (status === 202) {\n            this.commitSessionRetry(response);\n            return;\n        }\n\n        let { entries } = data;\n        // v2.1 API response format is different from v2.0. v2.1 returns individual upload entry directly inside data,\n        // while v2.0 returns a collection of entries under data.entries\n        if (!entries && data.id) {\n            entries = [data];\n        }\n\n        this.destroy();\n\n        if (this.successCallback && entries) {\n            this.successCallback(entries);\n        }\n    };\n\n    /**\n     * Commit error handler.\n     * Retries the commit or fails the multiput session.\n     *\n     * @private\n     * @param {Object} error\n     * @return {void}\n     */\n    commitSessionErrorHandler = (error: Object): void => {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        const { response } = error;\n\n        if (!response) {\n            // Some random error happened\n            this.consoleError(error);\n            return;\n        }\n\n        if (this.commitRetryCount >= this.config.retries) {\n            this.consoleLog('Too many commit failures, failing upload');\n            this.sessionErrorHandler(error, LOG_EVENT_TYPE_COMMIT_RETRIES_EXCEEDED, JSON.stringify(error));\n            return;\n        }\n\n        this.commitSessionRetry(response);\n    };\n\n    /**\n     * Retry commit.\n     * Retries the commit or fails the multiput session.\n     *\n     * @private\n     * @param {Object} response\n     * @return {void}\n     */\n    commitSessionRetry(response: Object): void {\n        const { status, headers } = response;\n        let retryAfterMs = DEFAULT_RETRY_DELAY_MS;\n\n        if (headers) {\n            const retryAfterSec = parseInt(headers['retry-after'], 10);\n\n            if (!Number.isNaN(retryAfterSec)) {\n                retryAfterMs = retryAfterSec * 1000;\n            }\n        }\n\n        const defaultRetryDelayMs = getBoundedExpBackoffRetryDelay(\n            this.config.initialRetryDelayMs,\n            this.config.maxRetryDelayMs,\n            this.commitRetryCount,\n        );\n        // If status is 202 then don't increment the retry count.\n        // In this case, frontend will keep retrying until it gets another status code.\n        // Retry interval = value specified for the Retry-After header in 202 response.\n        if (status !== 202) {\n            this.commitRetryCount += 1;\n        }\n\n        const retryDelayMs = retryAfterMs || defaultRetryDelayMs;\n        this.consoleLog(`Retrying commit in ${retryDelayMs} ms`);\n        this.commitSessionTimeout = setTimeout(this.commitSession, retryDelayMs);\n    }\n\n    /**\n     * Find first part in parts array that we can upload, and upload it.\n     *\n     * @private\n     * @return {void}\n     */\n    uploadNextPart(): void {\n        for (let i = this.firstUnuploadedPartIndex; i < this.parts.length; i += 1) {\n            const part = this.parts[i];\n\n            if (part.state === PART_STATE_DIGEST_READY) {\n                // Update the counters here instead of uploadPart because uploadPart\n                // can get called on retries\n                this.numPartsDigestReady -= 1;\n                this.numPartsUploading += 1;\n                if (part.isPaused) {\n                    part.unpause();\n                } else {\n                    part.upload();\n                }\n                break;\n            }\n        }\n    }\n\n    /**\n     * Checks if upload pipeline is full\n     *\n     * @private\n     * @return {boolean}\n     */\n    canStartMorePartUploads(): boolean {\n        return !this.isDestroyed() && this.numPartsUploading < this.config.parallelism && this.numPartsDigestReady > 0;\n    }\n\n    /**\n     * Functions that walk the parts array get called a lot, so we cache which part we should\n     * start work at to avoid always iterating through entire parts list.\n     *\n     * @private\n     * @return {void}\n     */\n    updateFirstUnuploadedPartIndex(): void {\n        let part = this.parts[this.firstUnuploadedPartIndex];\n        while (part && part.state === PART_STATE_UPLOADED) {\n            this.firstUnuploadedPartIndex += 1;\n            part = this.parts[this.firstUnuploadedPartIndex];\n        }\n    }\n\n    /**\n     * Get number of parts being uploaded\n     *\n     * @return {number}\n     */\n    getNumPartsUploading = (): number => this.numPartsUploading;\n\n    /**\n     * After session is created and we know the part size, populate the parts\n     * array.\n     *\n     * @private\n     * @return {void}\n     */\n    populateParts(): void {\n        this.numPartsNotStarted = Math.ceil(this.file.size / this.partSize);\n\n        for (let i = 0; i < this.numPartsNotStarted; i += 1) {\n            const offset = i * this.partSize;\n            const currentPartSize = Math.min(offset + this.partSize, this.file.size) - offset;\n            const part = new MultiputPart(\n                this.options,\n                i,\n                offset,\n                currentPartSize,\n                this.file.size,\n                this.sessionId,\n                this.sessionEndpoints,\n                this.config,\n                this.getNumPartsUploading,\n                this.partUploadSuccessHandler,\n                this.updateProgress,\n                this.partUploadErrorHandler,\n            );\n            this.parts.push(part);\n        }\n    }\n\n    /**\n     * Fails the session if the file's size or last modified has changed since the upload process\n     * began.\n     *\n     * This ensures that we don't upload a file that has parts from one file version and parts from\n     * another file version.\n     *\n     * This logic + the \"not found\" error logic in onWorkerError() is best effort and will not\n     * detect all possible file changes. This is because of browser differences. For example,\n     * -- In Safari, size and last modified will update when a file changes, and workers will\n     * get \"not found\" errors.\n     * -- In Chrome, size and last modified will update, but not in legacy drag and drop (that\n     * code path constructs a different file object). Workers will still get \"not found\" errors,\n     * though, so we can still detect changes even in legacy drag and drop.\n     * -- In IE 11/Edge, size will update but last modified will not. Workers will not get\n     * \"not found\" errors, but they may get a generic error saying that some bytes failed to be\n     * read.\n     * -- In Firefox, neither last modified nor size will update. Workers don't seem to get errors.\n     * (Not a whole lot we can do here...)\n     *\n     * Unfortunately, alternative solutions to catch more cases don't have a clear ROI (for\n     * example, doing a SHA-1 of the file before and after the upload is very expensive), so\n     * this is the best solution we have. We can revisit this if data shows that we need a better\n     * solution.\n     *\n     * @private\n     * @return {boolean} True if the session was failed, false if no action was taken\n     */\n    failSessionIfFileChangeDetected(): boolean {\n        const currentFileSize = this.file.size;\n        const currentFileLastModified = getFileLastModifiedAsISONoMSIfPossible(this.file);\n\n        if (currentFileSize !== this.initialFileSize || currentFileLastModified !== this.initialFileLastModified) {\n            const changeJSON = JSON.stringify({\n                oldSize: this.initialFileSize,\n                newSize: currentFileSize,\n                oldLastModified: this.initialFileLastModified,\n                newLastModified: currentFileLastModified,\n            });\n            // Leave IE with old behavior and kill upload\n            if (Browser.isIE()) {\n                this.sessionErrorHandler(null, LOG_EVENT_TYPE_FILE_CHANGED_DURING_UPLOAD, changeJSON);\n                return true;\n            }\n            // for evergreen browsers where the file change check does not work, log and continue with upload\n            // https://w3c.github.io/FileAPI/#file-section\n            this.consoleLog(`file properties changed during upload: ${changeJSON}`);\n            return false;\n        }\n\n        return false;\n    }\n\n    /**\n     * Cancels an upload in progress by cancelling all upload parts.\n     * This cannot be undone or resumed.\n     *\n     * @private\n     * @return {void}\n     */\n    cancel(): void {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        // Cancel individual upload parts\n        this.parts.forEach(part => {\n            part.cancel();\n        });\n\n        this.parts = [];\n        clearTimeout(this.createSessionTimeout);\n        clearTimeout(this.commitSessionTimeout);\n        this.abortSession();\n        this.destroy();\n    }\n\n    /**\n     * Resolves upload conflict by overwriting or renaming\n     *\n     * @param {Object} response data\n     * @return {Promise}\n     */\n    async resolveConflict(data: Object): Promise<any> {\n        if (this.overwrite && data.context_info) {\n            this.fileId = data.context_info.conflicts.id;\n            return;\n        }\n        if (this.conflictCallback) {\n            this.fileName = this.conflictCallback(this.fileName);\n            return;\n        }\n\n        const extension = this.fileName.substr(this.fileName.lastIndexOf('.')) || '';\n        // foo.txt => foo-1513385827917.txt\n        this.fileName = `${this.fileName.substr(0, this.fileName.lastIndexOf('.'))}-${Date.now()}${extension}`;\n    }\n\n    /**\n     * Returns detailed error response\n     *\n     * @param {Object} error\n     * @return {Object}\n     */\n    getErrorResponse(error: ?Object): Object {\n        if (!error) {\n            return {};\n        }\n\n        const { response } = error;\n        if (!response) {\n            return {};\n        }\n\n        if (response.status === 401) {\n            return response;\n        }\n\n        return response.data;\n    }\n}\n\nexport default MultiputUpload;\n"],"file":"MultiputUpload.js"}