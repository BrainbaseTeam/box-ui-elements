{"version":3,"sources":["../../../src/api/uploads/MultiputUpload.js"],"names":["noop","isNaN","getFileLastModifiedAsISONoMSIfPossible","getBoundedExpBackoffRetryDelay","retryNumOfTimes","digest","hexToBase64","createWorker","DEFAULT_RETRY_DELAY_MS","ERROR_CODE_UPLOAD_STORAGE_LIMIT_EXCEEDED","HTTP_STATUS_CODE_FORBIDDEN","MS_IN_S","MultiputPart","PART_STATE_UPLOADED","PART_STATE_UPLOADING","PART_STATE_DIGEST_READY","PART_STATE_NOT_STARTED","BaseMultiput","LOG_EVENT_TYPE_CREATE_SESSION_MISC_ERROR","LOG_EVENT_TYPE_CREATE_SESSION_RETRIES_EXCEEDED","LOG_EVENT_TYPE_FILE_CHANGED_DURING_UPLOAD","LOG_EVENT_TYPE_PART_UPLOAD_RETRIES_EXCEEDED","LOG_EVENT_TYPE_COMMIT_RETRIES_EXCEEDED","LOG_EVENT_TYPE_WEB_WORKER_ERROR","LOG_EVENT_TYPE_FILE_READER_RECEIVED_NOT_FOUND_ERROR","LOG_EVENT_TYPE_PART_DIGEST_RETRIES_EXCEEDED","MultiputUpload","options","config","createSession","uploadPart","listParts","commit","abort","logEvent","data","upload_url","getBaseUploadUrl","splitUrl","split","uploadHost","preflightResponse","isDestroyed","uploadUrl","getBaseUploadUrlFromPreflightResponse","createSessionUrl","includes","parallelism","postData","file_size","file","size","file_name","fileName","fileId","replace","folder_id","folderId","xhr","post","url","response","createSessionSuccessHandler","errorData","getErrorResponse","status","createSessionErrorHandler","code","context_info","session","errorCallback","resolveConflict","createSessionRetry","sessionErrorHandler","JSON","stringify","error","createSessionNumRetriesPerformed","retries","consoleLog","sessionUrl","sessionId","get","getSessionSuccessHandler","getSessionErrorHandler","part","numPartsUploading","numPartsUploaded","updateProgress","uploadedBytes","partSize","processNextParts","eventInfo","prevUploadedBytes","newUploadedBytes","totalUploadedBytes","progressCallback","loaded","total","failSessionIfFileChangeDetected","parts","length","fileSha1","commitSession","updateFirstUnuploadedPartIndex","canStartMorePartUploads","uploadNextPart","shouldComputeDigestForNextPart","computeDigestForNextPart","event","type","numPartsDigestComputing","index","timing","fileDigestTime","duration","sha1","sha1Worker","terminate","buffer","partInformation","offset","postMessage","fileSize","partContents","name","numDigestRetriesPerformed","retryDelayMs","initialRetryDelayMs","maxRetryDelayMs","setTimeout","computeDigestForPart","stats","totalPartReadTime","totalPartDigestTime","totalFileDigestTime","totalPartUploadTime","map","readTime","subtleCryptoTime","uploadTime","getPart","sort","part1","part2","attributes","fileLastModified","content_modified_at","clientEventInfo","avg_part_read_time","Math","round","avg_part_digest_time","avg_file_digest_time","avg_part_upload_time","headers","Digest","sessionEndpoints","then","commitSessionSuccessHandler","catch","commitSessionErrorHandler","commitSessionRetry","entries","id","destroy","successCallback","consoleError","commitRetryCount","numPartsNotStarted","numPartsDigestReady","firstUnuploadedPartIndex","clientId","isResumableUploadsEnabled","overwrite","initialFileSize","initialFileLastModified","addEventListener","onWorkerMessage","makePreflightRequest","createSessionTimeout","part_size","session_endpoints","upload_part","list_parts","log_event","populateParts","setFileInfo","getSessionInfo","nextUploadIndex","state","numUploadRetriesPerformed","numResumeRetries","retryAfterMs","retryAfterSec","parseInt","retryTimeout","forEach","cancel","reset","clearTimeout","commitSessionTimeout","abortSession","uploadOptions","upload","logEventType","logMessage","Error","resolve","reject","delete","digestReadahead","i","blob","slice","reader","window","FileReader","startTimestamp","Date","now","readFile","readCompleteTimestamp","sha256ArrayBuffer","sha256","btoa","reduce","call","Uint8Array","byte","String","fromCharCode","sendPartToWorker","digestCompleteTimestamp","partDigestTime","onPartDigestError","Number","defaultRetryDelayMs","ceil","currentPartSize","min","getNumPartsUploading","partUploadSuccessHandler","partUploadErrorHandler","push","currentFileSize","currentFileLastModified","oldSize","newSize","oldLastModified","newLastModified","conflicts","extension","substr","lastIndexOf"],"mappings":"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","sourcesContent":["/**\n * @flow\n * @file Multiput upload\n * @author Box\n */\n\nimport noop from 'lodash/noop';\nimport isNaN from 'lodash/isNaN';\nimport { getFileLastModifiedAsISONoMSIfPossible, getBoundedExpBackoffRetryDelay } from '../../utils/uploads';\nimport { retryNumOfTimes } from '../../utils/function';\nimport { digest } from '../../utils/webcrypto';\nimport hexToBase64 from '../../utils/base64';\nimport createWorker from '../../utils/uploadsSHA1Worker';\nimport {\n    DEFAULT_RETRY_DELAY_MS,\n    ERROR_CODE_UPLOAD_STORAGE_LIMIT_EXCEEDED,\n    HTTP_STATUS_CODE_FORBIDDEN,\n    MS_IN_S,\n} from '../../constants';\nimport MultiputPart, {\n    PART_STATE_UPLOADED,\n    PART_STATE_UPLOADING,\n    PART_STATE_DIGEST_READY,\n    PART_STATE_NOT_STARTED,\n} from './MultiputPart';\nimport BaseMultiput from './BaseMultiput';\n\n// Constants used for specifying log event types.\n\n// This type is a catch-all for create session errors that aren't 5xx's (for which we'll do\n// retries) and aren't specific 4xx's we know how to specifically handle (e.g. out of storage).\nconst LOG_EVENT_TYPE_CREATE_SESSION_MISC_ERROR = 'create_session_misc_error';\nconst LOG_EVENT_TYPE_CREATE_SESSION_RETRIES_EXCEEDED = 'create_session_retries_exceeded';\nconst LOG_EVENT_TYPE_FILE_CHANGED_DURING_UPLOAD = 'file_changed_during_upload';\nconst LOG_EVENT_TYPE_PART_UPLOAD_RETRIES_EXCEEDED = 'part_upload_retries_exceeded';\nconst LOG_EVENT_TYPE_COMMIT_RETRIES_EXCEEDED = 'commit_retries_exceeded';\nconst LOG_EVENT_TYPE_WEB_WORKER_ERROR = 'web_worker_error';\nconst LOG_EVENT_TYPE_FILE_READER_RECEIVED_NOT_FOUND_ERROR = 'file_reader_received_not_found_error';\nconst LOG_EVENT_TYPE_PART_DIGEST_RETRIES_EXCEEDED = 'part_digest_retries_exceeded';\n\nclass MultiputUpload extends BaseMultiput {\n    clientId: ?string;\n\n    commitRetryCount: number;\n\n    createSessionNumRetriesPerformed: number;\n\n    destinationFileId: ?string;\n\n    folderId: string;\n\n    fileSha1: ?string;\n\n    firstUnuploadedPartIndex: number;\n\n    initialFileLastModified: ?string;\n\n    initialFileSize: number;\n\n    isResumableUploadsEnabled: boolean;\n\n    successCallback: Function;\n\n    progressCallback: Function;\n\n    options: Options;\n\n    partSize: number;\n\n    parts: Array<MultiputPart>;\n\n    numPartsDigestComputing: number;\n\n    numPartsDigestReady: number;\n\n    numPartsNotStarted: number;\n\n    numPartsUploaded: number;\n\n    numPartsUploading: number;\n\n    numResumeRetries: number;\n\n    sessionEndpoints: Object;\n\n    sessionId: string;\n\n    totalUploadedBytes: number;\n\n    sha1Worker: Worker;\n\n    createSessionTimeout: TimeoutID;\n\n    commitSessionTimeout: TimeoutID;\n\n    /**\n     * [constructor]\n     *\n     * @param {Options} options\n     * @param {MultiputConfig} [config]\n     */\n    constructor(options: Options, config?: MultiputConfig) {\n        super(\n            options,\n            {\n                createSession: null,\n                uploadPart: null,\n                listParts: null,\n                commit: null,\n                abort: null,\n                logEvent: null,\n            },\n            config,\n        );\n        this.parts = [];\n        this.options = options;\n        this.fileSha1 = null;\n        this.totalUploadedBytes = 0;\n        this.numPartsNotStarted = 0; // # of parts yet to be processed\n        this.numPartsDigestComputing = 0; // # of parts sent to the digest worker\n        this.numPartsDigestReady = 0; // # of parts with digest finished that are waiting to be uploaded.\n        this.numPartsUploading = 0; // # of parts with upload requests currently inflight\n        this.numPartsUploaded = 0; // # of parts successfully uploaded\n        this.firstUnuploadedPartIndex = 0; // Index of first part that hasn't been uploaded yet.\n        this.createSessionNumRetriesPerformed = 0;\n        this.partSize = 0;\n        this.commitRetryCount = 0;\n        this.clientId = null;\n        this.isResumableUploadsEnabled = false;\n    }\n\n    /**\n     * Reset values for uploading process.\n     */\n    reset() {\n        this.parts = [];\n        this.fileSha1 = null;\n        this.totalUploadedBytes = 0;\n        this.numPartsNotStarted = 0; // # of parts yet to be processed\n        this.numPartsDigestComputing = 0; // # of parts sent to the digest worker\n        this.numPartsDigestReady = 0; // # of parts with digest finished that are waiting to be uploaded.\n        this.numPartsUploading = 0; // # of parts with upload requests currently inflight\n        this.numPartsUploaded = 0; // # of parts successfully uploaded\n        this.firstUnuploadedPartIndex = 0; // Index of first part that hasn't been uploaded yet.\n        this.createSessionNumRetriesPerformed = 0;\n        this.partSize = 0;\n        this.commitRetryCount = 0;\n    }\n\n    /**\n     * Set information about file being uploaded\n     *\n     *\n     * @param {Object} options\n     * @param {File} options.file\n     * @param {string} options.folderId - Untyped folder id (e.g. no \"folder_\" prefix)\n     * @param {string} [options.fileId] - Untyped file id (e.g. no \"file_\" prefix)\n     * @param {string} options.sessionId\n     * @param {Function} [options.errorCallback]\n     * @param {Function} [options.progressCallback]\n     * @param {Function} [options.successCallback]\n     * @return {void}\n     */\n    setFileInfo({\n        file,\n        folderId,\n        errorCallback,\n        progressCallback,\n        successCallback,\n        overwrite = true,\n        fileId,\n    }: {\n        errorCallback?: Function,\n        file: File,\n        fileId: ?string,\n        folderId: string,\n        overwrite?: boolean,\n        progressCallback?: Function,\n        successCallback?: Function,\n    }): void {\n        this.file = file;\n        this.fileName = this.file.name;\n        this.folderId = folderId;\n        this.errorCallback = errorCallback || noop;\n        this.progressCallback = progressCallback || noop;\n        this.successCallback = successCallback || noop;\n        this.overwrite = overwrite;\n        this.fileId = fileId;\n    }\n\n    /**\n     * Upload a given file\n     *\n     *\n     * @param {Object} options\n     * @param {File} options.file\n     * @param {string} options.folderId - Untyped folder id (e.g. no \"folder_\" prefix)\n     * @param {string} [options.fileId] - Untyped file id (e.g. no \"file_\" prefix)\n     * @param {Function} [options.errorCallback]\n     * @param {Function} [options.progressCallback]\n     * @param {Function} [options.successCallback]\n     * @return {void}\n     */\n    upload({\n        file,\n        folderId,\n        errorCallback,\n        progressCallback,\n        successCallback,\n        overwrite = true,\n        fileId,\n    }: {\n        errorCallback?: Function,\n        file: File,\n        fileId: ?string,\n        folderId: string,\n        overwrite?: boolean,\n        progressCallback?: Function,\n        successCallback?: Function,\n    }): void {\n        this.file = file;\n        this.fileName = this.file.name;\n        // These values are used as part of our (best effort) attempt to abort uploads if we detect\n        // a file change during the upload.\n        this.initialFileSize = this.file.size;\n        this.initialFileLastModified = getFileLastModifiedAsISONoMSIfPossible(this.file);\n        this.folderId = folderId;\n        this.errorCallback = errorCallback || noop;\n        this.progressCallback = progressCallback || noop;\n        this.successCallback = successCallback || noop;\n\n        this.sha1Worker = createWorker();\n        this.sha1Worker.addEventListener('message', this.onWorkerMessage);\n\n        this.overwrite = overwrite;\n        this.fileId = fileId;\n\n        this.makePreflightRequest();\n    }\n\n    /**\n     * Update uploadHost with preflight response and return the base uploadUrl\n     *\n     * @private\n     * @param {Object} response\n     * @param {Object} [response.data]\n     * @return {string}\n     */\n    getBaseUploadUrlFromPreflightResponse = ({ data }: { data: { upload_url?: string } }) => {\n        if (!data || !data.upload_url) {\n            return this.getBaseUploadUrl();\n        }\n\n        const splitUrl = data.upload_url.split('/');\n        // splitUrl[0] is the protocol (e.g., https:), splitUrl[2] is hostname (e.g., www.box.com)\n        this.uploadHost = `${splitUrl[0]}//${splitUrl[2]}`;\n        return this.getBaseUploadUrl();\n    };\n\n    /**\n     * Creates upload session. If a file ID is supplied, use the Chunked Upload File Version\n     * API to replace the file.\n     *\n     * @private\n     * @return {void}\n     */\n    preflightSuccessHandler = async (preflightResponse: Object): Promise<any> => {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        const uploadUrl = this.getBaseUploadUrlFromPreflightResponse(preflightResponse);\n        let createSessionUrl = `${uploadUrl}/files/upload_sessions`;\n\n        // Parallelism is currently detrimental to multiput upload performance in Zones, so set it to 1.\n        if (createSessionUrl.includes('fupload-ec2')) {\n            this.config.parallelism = 1;\n        }\n\n        // Set up post body\n        const postData: StringAnyMap = {\n            file_size: this.file.size,\n            file_name: this.fileName,\n        };\n\n        if (this.fileId) {\n            createSessionUrl = createSessionUrl.replace('upload_sessions', `${this.fileId}/upload_sessions`);\n        } else {\n            postData.folder_id = this.folderId;\n        }\n\n        try {\n            const response = await this.xhr.post({\n                url: createSessionUrl,\n                data: postData,\n            });\n            this.createSessionSuccessHandler(response.data);\n        } catch (error) {\n            const errorData = this.getErrorResponse(error);\n\n            if (errorData && errorData.status >= 500 && errorData.status < 600) {\n                this.createSessionErrorHandler(error);\n                return;\n            }\n\n            // Recover from 409 session_conflict.  The server will return the session information\n            // in context_info, so treat it as a success.\n            if (errorData && errorData.status === 409 && errorData.code === 'session_conflict') {\n                this.createSessionSuccessHandler(errorData.context_info.session);\n                return;\n            }\n\n            if (\n                (errorData &&\n                    (errorData.status === HTTP_STATUS_CODE_FORBIDDEN &&\n                        errorData.code === ERROR_CODE_UPLOAD_STORAGE_LIMIT_EXCEEDED)) ||\n                (errorData.status === HTTP_STATUS_CODE_FORBIDDEN &&\n                    errorData.code === 'access_denied_insufficient_permissions')\n            ) {\n                this.errorCallback(errorData);\n                return;\n            }\n\n            if (errorData && errorData.status === 409) {\n                this.resolveConflict(errorData);\n                this.createSessionRetry();\n                return;\n            }\n\n            // All other cases get treated as an upload failure.\n            this.sessionErrorHandler(error, LOG_EVENT_TYPE_CREATE_SESSION_MISC_ERROR, JSON.stringify(error));\n        }\n    };\n\n    /**\n     * Create session error handler.\n     * Retries the create session request or fails the upload.\n     *\n     * @private\n     * @param {Error} error\n     * @return {void}\n     */\n    createSessionErrorHandler = (error: Error): void => {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        if (this.createSessionNumRetriesPerformed < this.config.retries) {\n            this.createSessionRetry();\n            return;\n        }\n\n        this.consoleLog('Too many create session failures, failing upload');\n        this.sessionErrorHandler(error, LOG_EVENT_TYPE_CREATE_SESSION_RETRIES_EXCEEDED, JSON.stringify(error));\n    };\n\n    /**\n     * Schedule a retry for create session request upon failure\n     *\n     * @private\n     * @return {void}\n     */\n    createSessionRetry(): void {\n        const retryDelayMs = getBoundedExpBackoffRetryDelay(\n            this.config.initialRetryDelayMs,\n            this.config.maxRetryDelayMs,\n            this.createSessionNumRetriesPerformed,\n        );\n        this.createSessionNumRetriesPerformed += 1;\n        this.consoleLog(`Retrying create session in ${retryDelayMs} ms`);\n        this.createSessionTimeout = setTimeout(this.makePreflightRequest, retryDelayMs);\n    }\n\n    /**\n     * Handles a upload session success response\n     *\n     * @private\n     * @param {Object} data - Upload session creation success data\n     * @return {void}\n     */\n    createSessionSuccessHandler(data: any): void {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        const { id, part_size, session_endpoints } = data;\n\n        this.sessionId = id;\n        this.partSize = part_size;\n        this.sessionEndpoints = {\n            ...this.sessionEndpoints,\n            uploadPart: session_endpoints.upload_part,\n            listParts: session_endpoints.list_parts,\n            commit: session_endpoints.commit,\n            abort: session_endpoints.abort,\n            logEvent: session_endpoints.log_event,\n        };\n\n        this.populateParts();\n        this.processNextParts();\n    }\n\n    /**\n     * Resume uploading the given file\n     *\n     *\n     * @param {Object} options\n     * @param {File} options.file\n     * @param {string} options.folderId - Untyped folder id (e.g. no \"folder_\" prefix)\n     * @param {string} [options.fileId] - Untyped file id (e.g. no \"file_\" prefix)\n     * @param {string} options.sessionId\n     * @param {Function} [options.errorCallback]\n     * @param {Function} [options.progressCallback]\n     * @param {Function} [options.successCallback]\n     * @return {void}\n     */\n    resume({\n        file,\n        folderId,\n        errorCallback,\n        progressCallback,\n        sessionId,\n        successCallback,\n        overwrite = true,\n        fileId,\n    }: {\n        errorCallback?: Function,\n        file: File,\n        fileId: ?string,\n        folderId: string,\n        overwrite?: boolean,\n        progressCallback?: Function,\n        sessionId: string,\n        successCallback?: Function,\n    }): void {\n        this.setFileInfo({ file, folderId, errorCallback, progressCallback, successCallback, overwrite, fileId });\n        this.sessionId = sessionId;\n\n        if (!this.sha1Worker) {\n            this.sha1Worker = createWorker();\n        }\n        this.sha1Worker.addEventListener('message', this.onWorkerMessage);\n\n        this.getSessionInfo();\n    }\n\n    /**\n     * Get session information from API.\n     * Uses session info to commit a complete session or continue an in-progress session.\n     *\n     * @private\n     * @return {void}\n     */\n    getSessionInfo = async (): Promise<any> => {\n        const uploadUrl = this.getBaseUploadUrl();\n        const sessionUrl = `${uploadUrl}/files/upload_sessions/${this.sessionId}`;\n        try {\n            const response = await this.xhr.get({ url: sessionUrl });\n            this.getSessionSuccessHandler(response.data);\n        } catch (error) {\n            this.getSessionErrorHandler(error);\n        }\n    };\n\n    /**\n     * Handles a getSessionInfo success and either commits the session or continues to process\n     * the parts that still need to be uploaded.\n     *\n     * @param response\n     * @return {void}\n     */\n    getSessionSuccessHandler(data: any): void {\n        const { part_size, session_endpoints } = data;\n\n        // Set session information gotten from API response\n        this.partSize = part_size;\n        this.sessionEndpoints = {\n            ...this.sessionEndpoints,\n            uploadPart: session_endpoints.upload_part,\n            listParts: session_endpoints.list_parts,\n            commit: session_endpoints.commit,\n            abort: session_endpoints.abort,\n            logEvent: session_endpoints.log_event,\n        };\n\n        // Reset uploading process for parts that were in progress when the upload failed\n        let nextUploadIndex = this.firstUnuploadedPartIndex;\n        while (this.numPartsUploading > 0) {\n            const part = this.parts[nextUploadIndex];\n            if (part && part.state === PART_STATE_UPLOADING) {\n                part.state = PART_STATE_DIGEST_READY;\n                part.numUploadRetriesPerformed = 0;\n                part.timing = {};\n                part.uploadedBytes = 0;\n\n                this.numPartsUploading -= 1;\n                this.numPartsDigestReady += 1;\n            }\n            nextUploadIndex += 1;\n        }\n\n        this.processNextParts();\n    }\n\n    /**\n     * Handle error from getting upload session.\n     * Restart uploads without valid sessions from the beginning of the upload process.\n     *\n     * @param error\n     * @return {void}\n     */\n    getSessionErrorHandler(error: Error): void {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        const errorData = this.getErrorResponse(error);\n        if (this.numResumeRetries > this.config.retries) {\n            this.errorCallback(errorData);\n            return;\n        }\n\n        if (errorData && errorData.status === 429) {\n            let retryAfterMs = DEFAULT_RETRY_DELAY_MS;\n            if (errorData.headers) {\n                const retryAfterSec = parseInt(\n                    errorData.headers['retry-after'] || errorData.headers.get('Retry-After'),\n                    10,\n                );\n                if (!isNaN(retryAfterSec)) {\n                    retryAfterMs = retryAfterSec * MS_IN_S;\n                }\n            }\n            this.retryTimeout = setTimeout(this.getSessionInfo, retryAfterMs);\n            this.numResumeRetries += 1;\n        } else if (errorData && errorData.status >= 500) {\n            this.retryTimeout = setTimeout(this.getSessionInfo, 2 ** this.numResumeRetries * MS_IN_S);\n            this.numResumeRetries += 1;\n        } else {\n            // Restart upload process for errors resulting from invalid session\n            this.parts.forEach(part => {\n                part.cancel();\n            });\n            this.reset();\n\n            // Abort session\n            clearTimeout(this.createSessionTimeout);\n            clearTimeout(this.commitSessionTimeout);\n            this.abortSession();\n            // Restart the uploading process from the beginning\n            const uploadOptions: Object = {\n                file: this.file,\n                folderId: this.folderId,\n                errorCallback: this.errorCallback,\n                progressCallback: this.progressCallback,\n                successCallback: this.successCallback,\n                overwrite: this.overwrite,\n                fileId: this.fileId,\n            };\n            this.upload(uploadOptions);\n        }\n    }\n\n    /**\n     * Session error handler.\n     * Retries the create session request or fails the upload.\n     *\n     * @private\n     * @param {?Error} error\n     * @param {string} logEventType\n     * @param {string} [logMessage]\n     * @return {Promise}\n     */\n    async sessionErrorHandler(error: ?Error, logEventType: string, logMessage?: string): Promise<any> {\n        if (!this.isResumableUploadsEnabled) {\n            this.destroy();\n        }\n        const errorData = this.getErrorResponse(error);\n        this.errorCallback(errorData);\n\n        try {\n            if (!this.sessionEndpoints.logEvent) {\n                throw new Error('logEvent endpoint not found');\n            }\n\n            await retryNumOfTimes(\n                (resolve: Function, reject: Function): void => {\n                    this.logEvent(logEventType, logMessage)\n                        .then(resolve)\n                        .catch(reject);\n                },\n                this.config.retries,\n                this.config.initialRetryDelayMs,\n            );\n            if (!this.isResumableUploadsEnabled) {\n                this.abortSession();\n            }\n        } catch (err) {\n            if (!this.isResumableUploadsEnabled) {\n                this.abortSession();\n            }\n        }\n    }\n\n    /**\n     * Aborts the upload session\n     *\n     * @private\n     * @return {void}\n     */\n    abortSession(): void {\n        if (this.sha1Worker) {\n            this.sha1Worker.terminate();\n        }\n\n        if (this.sessionEndpoints.abort && this.sessionId) {\n            this.xhr\n                .delete({\n                    url: this.sessionEndpoints.abort,\n                })\n                .then(() => {\n                    this.sessionId = '';\n                });\n        }\n    }\n\n    /**\n     * Part upload success handler\n     *\n     * @private\n     * @param {MultiputPart} part\n     * @return {void}\n     */\n    partUploadSuccessHandler = (part: MultiputPart): void => {\n        this.numPartsUploading -= 1;\n        this.numPartsUploaded += 1;\n        this.updateProgress(part.uploadedBytes, this.partSize);\n        this.processNextParts();\n    };\n\n    /**\n     * Part upload error handler\n     *\n     * @private\n     * @param {Error} error\n     * @param {string} eventInfo\n     * @return {void}\n     */\n    partUploadErrorHandler = (error: Error, eventInfo: string): void => {\n        this.sessionErrorHandler(error, LOG_EVENT_TYPE_PART_UPLOAD_RETRIES_EXCEEDED, eventInfo);\n    };\n\n    /**\n     * Update upload progress\n     *\n     * @private\n     * @param {number} prevUploadedBytes\n     * @param {number} newUploadedBytes\n     * @return {void}\n     */\n    updateProgress = (prevUploadedBytes: number, newUploadedBytes: number): void => {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        this.totalUploadedBytes += newUploadedBytes - prevUploadedBytes;\n        this.progressCallback({\n            loaded: this.totalUploadedBytes,\n            total: this.file.size,\n        });\n    };\n\n    /**\n     * Attempts to process more parts, except in the case where everything is done or we detect\n     * a file change (in which case we want to abort and not process more parts).\n     *\n     * @private\n     * @return {void}\n     */\n    processNextParts = (): void => {\n        if (this.failSessionIfFileChangeDetected()) {\n            return;\n        }\n\n        if (this.numPartsUploaded === this.parts.length && this.fileSha1) {\n            this.commitSession();\n            return;\n        }\n\n        this.updateFirstUnuploadedPartIndex();\n\n        while (this.canStartMorePartUploads()) {\n            this.uploadNextPart();\n        }\n\n        if (this.shouldComputeDigestForNextPart()) {\n            this.computeDigestForNextPart();\n        }\n    };\n\n    /**\n     * We compute digest for parts one at a time.  This is done for simplicity and also to guarantee that\n     * we send parts in order to the web sha1Worker (which is computing the digest for the entire file).\n     *\n     * @private\n     * @return {boolean} true if there is work to do, false otherwise.\n     */\n    shouldComputeDigestForNextPart(): boolean {\n        return (\n            !this.isDestroyed() &&\n            this.numPartsDigestComputing === 0 &&\n            this.numPartsNotStarted > 0 &&\n            this.numPartsDigestReady < this.config.digestReadahead\n        );\n    }\n\n    /**\n     * Find first part in parts array that doesn't have a digest, and compute its digest.\n\n     * @private\n     * @return {void}\n     */\n    computeDigestForNextPart(): void {\n        for (let i = this.firstUnuploadedPartIndex; i < this.parts.length; i += 1) {\n            const part = this.parts[i];\n            if (part.state === PART_STATE_NOT_STARTED) {\n                // Update the counters here instead of computeDigestForPart because computeDigestForPart\n                // can get called on retries\n                this.numPartsNotStarted -= 1;\n                this.numPartsDigestComputing += 1;\n                this.computeDigestForPart(part);\n                return;\n            }\n        }\n    }\n\n    /**\n     * Compute digest for this part\n     *\n     * @private\n     * @param {MultiputPart} part\n     * @return {Promise}\n     */\n    async computeDigestForPart(part: MultiputPart): Promise<any> {\n        const blob = this.file.slice(part.offset, part.offset + this.partSize);\n        const reader = new window.FileReader();\n        const startTimestamp = Date.now();\n\n        try {\n            const {\n                buffer,\n                readCompleteTimestamp,\n            }: {\n                buffer: ArrayBuffer,\n                readCompleteTimestamp: number,\n            } = await this.readFile(reader, blob);\n            const sha256ArrayBuffer = await digest('SHA-256', buffer);\n            const sha256 = btoa(\n                [].reduce.call(new Uint8Array(sha256ArrayBuffer), (data, byte) => data + String.fromCharCode(byte), ''),\n            );\n            this.sendPartToWorker(part, buffer);\n\n            part.sha256 = sha256;\n            part.state = PART_STATE_DIGEST_READY;\n            part.blob = blob;\n\n            this.numPartsDigestReady += 1;\n            const digestCompleteTimestamp = Date.now();\n\n            part.timing = {\n                partDigestTime: digestCompleteTimestamp - startTimestamp,\n                readTime: readCompleteTimestamp - startTimestamp,\n                subtleCryptoTime: digestCompleteTimestamp - readCompleteTimestamp,\n            };\n\n            this.processNextParts();\n        } catch (error) {\n            this.onPartDigestError(error, part);\n        }\n    }\n\n    /**\n     * Deal with a message from the worker (either a part sha-1 ready, file sha-1 ready, or error).\n     *\n     * @private\n     * @param {object} event\n     * @return {void}\n     */\n    onWorkerMessage = (event: Object) => {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        const { data } = event;\n        if (data.type === 'partDone') {\n            this.numPartsDigestComputing -= 1;\n            const { part } = data;\n            this.parts[part.index].timing.fileDigestTime = data.duration;\n            this.processNextParts();\n        } else if (data.type === 'done') {\n            this.fileSha1 = hexToBase64(data.sha1);\n            this.sha1Worker.terminate();\n            this.processNextParts();\n        } else if (data.type === 'error') {\n            this.sessionErrorHandler(null, LOG_EVENT_TYPE_WEB_WORKER_ERROR, JSON.stringify(data));\n        }\n    };\n\n    /**\n     * Sends a part to the sha1Worker\n     *\n     * @private\n     * @param {MultiputPart} part\n     * @param {ArrayBuffer} buffer\n     * @return {void}\n     */\n    sendPartToWorker = (part: MultiputPart, buffer: ArrayBuffer): void => {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        // Don't send entire part since XHR can't be cloned\n        const partInformation = {\n            index: part.index,\n            offset: part.offset,\n            size: part.partSize,\n        };\n        this.sha1Worker.postMessage(\n            {\n                part: partInformation,\n                fileSize: this.file.size,\n                partContents: buffer,\n            },\n            [buffer], // This transfers the ArrayBuffer to the worker context without copying contents.\n        );\n        this.consoleLog(`Part sent to worker: ${JSON.stringify(part)}.}`);\n    };\n\n    /**\n     * Error handler for part digest computation\n     *\n     * @private\n     * @param {Error} error\n     * @param {MultiputPart} part\n     * @return {void}\n     */\n    onPartDigestError = (error: Error, part: MultiputPart): void => {\n        this.consoleLog(`Error computing digest for part ${JSON.stringify(part)}: ${JSON.stringify(error)}`);\n\n        // When a FileReader is processing a file that changes on disk, Chrome reports a 'NotFoundError'\n        // and Safari reports a 'NOT_FOUND_ERR'. (Other browsers seem to allow the reader to keep\n        // going, either with the old version of the new file or the new one.) Since the error name\n        // implies that retrying will not help, we fail the session.\n        if (error.name === 'NotFoundError' || error.name === 'NOT_FOUND_ERR') {\n            this.sessionErrorHandler(null, LOG_EVENT_TYPE_FILE_READER_RECEIVED_NOT_FOUND_ERROR, JSON.stringify(error));\n            return;\n        }\n\n        if (this.failSessionIfFileChangeDetected()) {\n            return;\n        }\n\n        if (part.numDigestRetriesPerformed >= this.config.retries) {\n            this.sessionErrorHandler(null, LOG_EVENT_TYPE_PART_DIGEST_RETRIES_EXCEEDED, JSON.stringify(error));\n            return;\n        }\n\n        const retryDelayMs = getBoundedExpBackoffRetryDelay(\n            this.config.initialRetryDelayMs,\n            this.config.maxRetryDelayMs,\n            part.numDigestRetriesPerformed,\n        );\n        part.numDigestRetriesPerformed += 1;\n        this.consoleLog(`Retrying digest work for part ${JSON.stringify(part)} in ${retryDelayMs} ms`);\n\n        setTimeout(() => {\n            this.computeDigestForPart(part);\n        }, retryDelayMs);\n    };\n\n    /**\n     * Send a request to commit the upload.\n     *\n     * @private\n     * @return {void}\n     */\n    commitSession = (): void => {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        const stats = {\n            totalPartReadTime: 0,\n            totalPartDigestTime: 0,\n            totalFileDigestTime: 0,\n            totalPartUploadTime: 0,\n        };\n\n        const data = {\n            parts: this.parts\n                .map(part => {\n                    stats.totalPartReadTime += part.timing.readTime;\n                    stats.totalPartDigestTime += part.timing.subtleCryptoTime;\n                    stats.totalFileDigestTime += part.timing.fileDigestTime;\n                    stats.totalPartUploadTime += part.timing.uploadTime;\n                    return part.getPart();\n                })\n                .sort((part1, part2) => part1.offset - part2.offset),\n            attributes: {},\n        };\n\n        const fileLastModified = getFileLastModifiedAsISONoMSIfPossible(this.file);\n        if (fileLastModified) {\n            data.attributes.content_modified_at = fileLastModified;\n        }\n\n        const clientEventInfo = {\n            avg_part_read_time: Math.round(stats.totalPartReadTime / this.parts.length),\n            avg_part_digest_time: Math.round(stats.totalPartDigestTime / this.parts.length),\n            avg_file_digest_time: Math.round(stats.totalFileDigestTime / this.parts.length),\n            avg_part_upload_time: Math.round(stats.totalPartUploadTime / this.parts.length),\n        };\n\n        // To make flow stop complaining about this.fileSha1 could potentially be undefined/null\n        const fileSha1: string = (this.fileSha1: any);\n        const headers = {\n            Digest: `sha=${fileSha1}`,\n            'X-Box-Client-Event-Info': JSON.stringify(clientEventInfo),\n        };\n\n        this.xhr\n            .post({ url: this.sessionEndpoints.commit, data, headers })\n            .then(this.commitSessionSuccessHandler)\n            .catch(this.commitSessionErrorHandler);\n    };\n\n    /**\n     * Commit response handler.  Succeeds the upload, retries the commit on 202\n     *\n     * @private\n     * @param {Object} response\n     * @return {void}\n     */\n    commitSessionSuccessHandler = (response: Object): void => {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        const { status, data } = response;\n\n        if (status === 202) {\n            this.commitSessionRetry(response);\n            return;\n        }\n\n        let { entries } = data;\n        // v2.1 API response format is different from v2.0. v2.1 returns individual upload entry directly inside data,\n        // while v2.0 returns a collection of entries under data.entries\n        if (!entries && data.id) {\n            entries = [data];\n        }\n\n        this.destroy();\n\n        if (this.successCallback && entries) {\n            this.successCallback(entries);\n        }\n    };\n\n    /**\n     * Commit error handler.\n     * Retries the commit or fails the multiput session.\n     *\n     * @private\n     * @param {Object} error\n     * @return {void}\n     */\n    commitSessionErrorHandler = (error: Object): void => {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        const { response } = error;\n\n        if (!response) {\n            // Some random error happened\n            this.consoleError(error);\n            return;\n        }\n\n        if (this.commitRetryCount >= this.config.retries) {\n            this.consoleLog('Too many commit failures, failing upload');\n            this.sessionErrorHandler(error, LOG_EVENT_TYPE_COMMIT_RETRIES_EXCEEDED, JSON.stringify(error));\n            return;\n        }\n\n        this.commitSessionRetry(response);\n    };\n\n    /**\n     * Retry commit.\n     * Retries the commit or fails the multiput session.\n     *\n     * @private\n     * @param {Object} response\n     * @return {void}\n     */\n    commitSessionRetry(response: Object): void {\n        const { status, headers } = response;\n        let retryAfterMs = DEFAULT_RETRY_DELAY_MS;\n\n        if (headers) {\n            const retryAfterSec = parseInt(headers['retry-after'], 10);\n\n            if (!Number.isNaN(retryAfterSec)) {\n                retryAfterMs = retryAfterSec * 1000;\n            }\n        }\n\n        const defaultRetryDelayMs = getBoundedExpBackoffRetryDelay(\n            this.config.initialRetryDelayMs,\n            this.config.maxRetryDelayMs,\n            this.commitRetryCount,\n        );\n        // If status is 202 then don't increment the retry count.\n        // In this case, frontend will keep retrying until it gets another status code.\n        // Retry interval = value specified for the Retry-After header in 202 response.\n        if (status !== 202) {\n            this.commitRetryCount += 1;\n        }\n\n        const retryDelayMs = retryAfterMs || defaultRetryDelayMs;\n        this.consoleLog(`Retrying commit in ${retryDelayMs} ms`);\n        this.commitSessionTimeout = setTimeout(this.commitSession, retryDelayMs);\n    }\n\n    /**\n     * Find first part in parts array that we can upload, and upload it.\n     *\n     * @private\n     * @return {void}\n     */\n    uploadNextPart(): void {\n        for (let i = this.firstUnuploadedPartIndex; i < this.parts.length; i += 1) {\n            const part = this.parts[i];\n\n            if (part.state === PART_STATE_DIGEST_READY) {\n                // Update the counters here instead of uploadPart because uploadPart\n                // can get called on retries\n                this.numPartsDigestReady -= 1;\n                this.numPartsUploading += 1;\n                part.upload();\n                break;\n            }\n        }\n    }\n\n    /**\n     * Checks if upload pipeline is full\n     *\n     * @private\n     * @return {boolean}\n     */\n    canStartMorePartUploads(): boolean {\n        return !this.isDestroyed() && this.numPartsUploading < this.config.parallelism && this.numPartsDigestReady > 0;\n    }\n\n    /**\n     * Functions that walk the parts array get called a lot, so we cache which part we should\n     * start work at to avoid always iterating through entire parts list.\n     *\n     * @private\n     * @return {void}\n     */\n    updateFirstUnuploadedPartIndex(): void {\n        let part = this.parts[this.firstUnuploadedPartIndex];\n        while (part && part.state === PART_STATE_UPLOADED) {\n            this.firstUnuploadedPartIndex += 1;\n            part = this.parts[this.firstUnuploadedPartIndex];\n        }\n    }\n\n    /**\n     * Get number of parts being uploaded\n     *\n     * @return {number}\n     */\n    getNumPartsUploading = (): number => this.numPartsUploading;\n\n    /**\n     * After session is created and we know the part size, populate the parts\n     * array.\n     *\n     * @private\n     * @return {void}\n     */\n    populateParts(): void {\n        this.numPartsNotStarted = Math.ceil(this.file.size / this.partSize);\n\n        for (let i = 0; i < this.numPartsNotStarted; i += 1) {\n            const offset = i * this.partSize;\n            const currentPartSize = Math.min(offset + this.partSize, this.file.size) - offset;\n            const part = new MultiputPart(\n                this.options,\n                i,\n                offset,\n                currentPartSize,\n                this.file.size,\n                this.sessionId,\n                this.sessionEndpoints,\n                this.config,\n                this.getNumPartsUploading,\n                this.partUploadSuccessHandler,\n                this.updateProgress,\n                this.partUploadErrorHandler,\n            );\n            this.parts.push(part);\n        }\n    }\n\n    /**\n     * Fails the session if the file's size or last modified has changed since the upload process\n     * began.\n     *\n     * This ensures that we don't upload a file that has parts from one file version and parts from\n     * another file version.\n     *\n     * This logic + the \"not found\" error logic in onWorkerError() is best effort and will not\n     * detect all possible file changes. This is because of browser differences. For example,\n     * -- In Safari, size and last modified will update when a file changes, and workers will\n     * get \"not found\" errors.\n     * -- In Chrome, size and last modified will update, but not in legacy drag and drop (that\n     * code path constructs a different file object). Workers will still get \"not found\" errors,\n     * though, so we can still detect changes even in legacy drag and drop.\n     * -- In IE 11/Edge, size will update but last modified will not. Workers will not get\n     * \"not found\" errors, but they may get a generic error saying that some bytes failed to be\n     * read.\n     * -- In Firefox, neither last modified nor size will update. Workers don't seem to get errors.\n     * (Not a whole lot we can do here...)\n     *\n     * Unfortunately, alternative solutions to catch more cases don't have a clear ROI (for\n     * example, doing a SHA-1 of the file before and after the upload is very expensive), so\n     * this is the best solution we have. We can revisit this if data shows that we need a better\n     * solution.\n     *\n     * @private\n     * @return {boolean} True if the session was failed, false if no action was taken\n     */\n    failSessionIfFileChangeDetected(): boolean {\n        const currentFileSize = this.file.size;\n        const currentFileLastModified = getFileLastModifiedAsISONoMSIfPossible(this.file);\n\n        if (currentFileSize !== this.initialFileSize || currentFileLastModified !== this.initialFileLastModified) {\n            this.sessionErrorHandler(\n                null,\n                LOG_EVENT_TYPE_FILE_CHANGED_DURING_UPLOAD,\n                JSON.stringify({\n                    oldSize: this.initialFileSize,\n                    newSize: currentFileSize,\n                    oldLastModified: this.initialFileLastModified,\n                    newLastModified: currentFileLastModified,\n                }),\n            );\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Cancels an upload in progress by cancelling all upload parts.\n     * This cannot be undone or resumed.\n     *\n     * @private\n     * @return {void}\n     */\n    cancel(): void {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        // Cancel individual upload parts\n        this.parts.forEach(part => {\n            part.cancel();\n        });\n\n        this.parts = [];\n        clearTimeout(this.createSessionTimeout);\n        clearTimeout(this.commitSessionTimeout);\n        this.abortSession();\n        this.destroy();\n    }\n\n    /**\n     * Resolves upload conflict by overwriting or renaming\n     *\n     * @param {Object} response data\n     * @return {Promise}\n     */\n    async resolveConflict(data: Object): Promise<any> {\n        if (this.overwrite && data.context_info) {\n            this.fileId = data.context_info.conflicts.id;\n            return;\n        }\n\n        const extension = this.fileName.substr(this.fileName.lastIndexOf('.')) || '';\n        // foo.txt => foo-1513385827917.txt\n        this.fileName = `${this.fileName.substr(0, this.fileName.lastIndexOf('.'))}-${Date.now()}${extension}`;\n    }\n\n    /**\n     * Returns detailed error response\n     *\n     * @param {Object} error\n     * @return {Object}\n     */\n    getErrorResponse(error: ?Object): Object {\n        if (!error) {\n            return {};\n        }\n\n        const { response } = error;\n        if (!response) {\n            return {};\n        }\n\n        if (response.status === 401) {\n            return response;\n        }\n\n        return response.data;\n    }\n}\n\nexport default MultiputUpload;\n"],"file":"MultiputUpload.js"}