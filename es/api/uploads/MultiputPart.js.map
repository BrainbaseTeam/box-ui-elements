{"version":3,"sources":["../../../src/api/uploads/MultiputPart.js"],"names":["noop","getProp","updateQueryParameters","getBoundedExpBackoffRetryDelay","retryNumOfTimes","BaseMultiput","HTTP_PUT","PART_STATE_NOT_STARTED","PART_STATE_DIGEST_READY","PART_STATE_UPLOADING","PART_STATE_UPLOADED","MultiputPart","options","index","offset","partSize","fileSize","sessionId","sessionEndpoints","config","getNumPartsUploading","onSuccess","onProgress","onError","JSON","stringify","state","uploadedBytes","numUploadRetriesPerformed","numDigestRetriesPerformed","sha256","timing","data","part","isDestroyedOrPaused","Error","blob","clientEventInfo","documentHidden","document","hidden","digest_retries","parts_uploading","headers","Digest","rangeEnd","startTimestamp","Date","now","xhr","uploadFile","url","uploadPart","method","successHandler","uploadSuccessHandler","errorHandler","uploadErrorHandler","progressHandler","uploadProgressHandler","withIdleTimeout","idleTimeoutDuration","requestTimeoutMs","consoleLog","toJSON","uploadTime","event","newUploadedBytes","parseInt","loaded","prevUploadedBytes","error","xhr_ready_state","xhr_status_text","message","eventInfo","id","eventInfoString","logEvent","resolve","reject","then","catch","retries","initialRetryDelayMs","e","retryDelayMs","maxRetryDelayMs","retryTimeout","setTimeout","retryUpload","listParts","parts","length","part_id","response","status","upload","partIndex","limit","params","endpoint","get","entries","isPaused","clearTimeout","destroy","abort","isDestroyed"],"mappings":"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","sourcesContent":["/**\n * @flow\n * @file Multiput upload part\n * @author Box\n */\nimport noop from 'lodash/noop';\nimport getProp from 'lodash/get';\nimport { updateQueryParameters } from '../../utils/url';\nimport { getBoundedExpBackoffRetryDelay } from '../../utils/uploads';\nimport { retryNumOfTimes } from '../../utils/function';\n\nimport BaseMultiput from './BaseMultiput';\n\nimport { HTTP_PUT } from '../../constants';\n\nimport type { MultiputConfig, MultiputData } from '../../common/types/upload';\nimport type { APIOptions } from '../../common/types/api';\n\nconst PART_STATE_NOT_STARTED: 0 = 0;\nconst PART_STATE_DIGEST_READY: 1 = 1;\nconst PART_STATE_UPLOADING: 2 = 2;\nconst PART_STATE_UPLOADED: 3 = 3;\n\nclass MultiputPart extends BaseMultiput {\n    index: number;\n\n    numDigestRetriesPerformed: number;\n\n    numUploadRetriesPerformed: number;\n\n    offset: number;\n\n    sha256: string;\n\n    partSize: number;\n\n    state:\n        | typeof PART_STATE_NOT_STARTED\n        | typeof PART_STATE_DIGEST_READY\n        | typeof PART_STATE_UPLOADING\n        | typeof PART_STATE_UPLOADED;\n\n    timing: Object;\n\n    uploadedBytes: number;\n\n    onProgress: Function;\n\n    onSuccess: Function;\n\n    onError: Function;\n\n    data: MultiputData;\n\n    config: MultiputConfig;\n\n    id: string;\n\n    retryTimeout: TimeoutID;\n\n    blob: ?Blob;\n\n    rangeEnd: number;\n\n    startTimestamp: number;\n\n    getNumPartsUploading: Function;\n\n    fileSize: number;\n\n    isPaused: boolean; // For resumable uploads.  When an error happens, all parts for an upload get paused.  This\n    // is not a separate state because a paused upload transitions to the DIGEST_READY state immediately\n    // so MultiputUpload can upload the part again.\n\n    /**\n     * [constructor]\n     *\n     * @param {Options} options\n     * @param {number} index - 0-based index of this part in array of all parts\n     * @param {number} offset - Starting byte offset of this part's range\n     * @param {number} partSize - Size of this part in bytes\n     * @param {number} sessionId\n     * @param {Object} sessionEndpoints\n     * @param {MultiputConfig} config\n     * @param {Function} getNumPartsUploading\n     * @param {Function} [onSuccess]\n     * @param {Function} [onProgress]\n     * @param {Function} [onError]\n     * @return {void}\n     */\n    constructor(\n        options: APIOptions,\n        index: number,\n        offset: number,\n        partSize: number,\n        fileSize: number,\n        sessionId: string,\n        sessionEndpoints: Object,\n        config: MultiputConfig,\n        getNumPartsUploading: Function,\n        onSuccess?: Function,\n        onProgress?: Function,\n        onError?: Function,\n    ): void {\n        super(options, sessionEndpoints, config);\n\n        this.index = index;\n        this.numDigestRetriesPerformed = 0;\n        this.numUploadRetriesPerformed = 0;\n        this.offset = offset;\n        this.partSize = partSize;\n        this.fileSize = fileSize;\n        this.state = PART_STATE_NOT_STARTED;\n        this.timing = {};\n        this.uploadedBytes = 0;\n        this.data = {};\n        this.config = config;\n        this.rangeEnd = offset + partSize - 1;\n        if (this.rangeEnd > fileSize - 1) {\n            this.rangeEnd = fileSize - 1;\n        }\n        this.isPaused = false;\n\n        this.onSuccess = onSuccess || noop;\n        this.onError = onError || noop;\n        this.onProgress = onProgress || noop;\n        this.getNumPartsUploading = getNumPartsUploading;\n    }\n\n    toJSON = () =>\n        JSON.stringify({\n            index: this.index,\n            offset: this.offset,\n            partSize: this.partSize,\n            state: this.state,\n            uploadedBytes: this.uploadedBytes,\n            numUploadRetriesPerformed: this.numUploadRetriesPerformed,\n            numDigestRetriesPerformed: this.numDigestRetriesPerformed,\n            sha256: this.sha256,\n            timing: this.timing,\n        });\n\n    /**\n     * Returns file part information from the server after part upload is successful\n     *\n     * @return {Object}\n     */\n    getPart = (): Object => this.data.part || {};\n\n    /**\n     * Uploads this Part via the API. Will retry on network failures.\n     *\n     * @return {void}\n     */\n    upload = (): void => {\n        if (this.isDestroyedOrPaused()) {\n            return;\n        }\n\n        if (!this.sha256) {\n            throw new Error('Part SHA-256 unavailable');\n        }\n\n        if (!this.blob) {\n            throw new Error('Part blob unavailable');\n        }\n\n        const clientEventInfo = {\n            documentHidden: document.hidden,\n            digest_retries: this.numDigestRetriesPerformed,\n            timing: this.timing,\n            parts_uploading: this.getNumPartsUploading(),\n        };\n\n        const headers = {\n            'Content-Type': 'application/octet-stream',\n            Digest: `sha-256=${this.sha256}`,\n            'Content-Range': `bytes ${this.offset}-${this.rangeEnd}/${this.fileSize}`,\n            'X-Box-Client-Event-Info': JSON.stringify(clientEventInfo),\n        };\n\n        this.state = PART_STATE_UPLOADING;\n\n        this.startTimestamp = Date.now();\n        this.xhr.uploadFile({\n            url: this.sessionEndpoints.uploadPart,\n            data: this.blob,\n            headers,\n            method: HTTP_PUT,\n            successHandler: this.uploadSuccessHandler,\n            errorHandler: this.uploadErrorHandler,\n            progressHandler: this.uploadProgressHandler,\n            withIdleTimeout: true,\n            idleTimeoutDuration: this.config.requestTimeoutMs,\n        });\n    };\n\n    /**\n     * Handler for upload part success\n     *\n     * @param {Object} data\n     * @return {void}\n     */\n    uploadSuccessHandler = ({ data }: { data: Object }) => {\n        if (this.isDestroyedOrPaused()) {\n            return;\n        }\n\n        this.state = PART_STATE_UPLOADED;\n        this.consoleLog(`Upload completed: ${this.toJSON()}.`);\n        this.data = data;\n        this.blob = null;\n        this.timing.uploadTime = Date.now() - this.startTimestamp;\n\n        this.onSuccess(this);\n\n        this.uploadedBytes = this.partSize;\n    };\n\n    /**\n     * Handler for upload part progress event\n     *\n     * @param {ProgressEvent} data\n     * @return {void}\n     */\n    uploadProgressHandler = (event: ProgressEvent) => {\n        if (this.isDestroyedOrPaused()) {\n            return;\n        }\n\n        const newUploadedBytes = parseInt(event.loaded, 10);\n        const prevUploadedBytes = this.uploadedBytes;\n        this.uploadedBytes = newUploadedBytes;\n\n        this.onProgress(prevUploadedBytes, newUploadedBytes);\n    };\n\n    /**\n     * Handler for upload part error\n     *\n     * @param {Error} error\n     * @return {void}\n     */\n    uploadErrorHandler = async (error: Error) => {\n        if (this.isDestroyedOrPaused()) {\n            // Ignore abort() error by checking this.isPaused\n            return;\n        }\n\n        const xhr_ready_state = getProp(this.xhr, 'xhr.readyState', null);\n        const xhr_status_text = getProp(this.xhr, 'xhr.statusText', '');\n\n        this.consoleLog(`Upload failure ${error.message} for part ${this.toJSON()}. XHR state: ${xhr_ready_state}.`);\n\n        const eventInfo = {\n            message: error.message,\n            part: {\n                uploadedBytes: this.uploadedBytes,\n                id: this.id,\n                index: this.index,\n                offset: this.offset,\n            },\n            xhr_ready_state,\n            xhr_status_text,\n        };\n\n        const eventInfoString = JSON.stringify(eventInfo);\n\n        if (this.sessionEndpoints.logEvent) {\n            retryNumOfTimes(\n                (resolve: Function, reject: Function): void => {\n                    this.logEvent('part_failure', eventInfoString)\n                        .then(resolve)\n                        .catch(reject);\n                },\n                this.config.retries,\n                this.config.initialRetryDelayMs,\n            ).catch(e => this.consoleLog(`Failure in logEvent: ${e.message}`));\n        } else {\n            this.consoleLog('logEvent endpoint not found');\n        }\n\n        if (this.numUploadRetriesPerformed >= this.config.retries) {\n            this.onError(error, eventInfoString);\n            return;\n        }\n\n        const retryDelayMs = getBoundedExpBackoffRetryDelay(\n            this.config.initialRetryDelayMs,\n            this.config.maxRetryDelayMs,\n            this.numUploadRetriesPerformed,\n        );\n\n        this.numUploadRetriesPerformed += 1;\n        this.consoleLog(`Retrying uploading part ${this.toJSON()} in ${retryDelayMs} ms`);\n        this.retryTimeout = setTimeout(this.retryUpload, retryDelayMs);\n    };\n\n    /**\n     * Retry uploading part\n     *\n     * @return {Promise}\n     */\n    retryUpload = async (): Promise<any> => {\n        if (this.isDestroyedOrPaused()) {\n            return;\n        }\n\n        try {\n            const parts = await this.listParts(this.index, 1);\n\n            if (parts && parts.length === 1 && parts[0].offset === this.offset && parts[0].part_id) {\n                this.consoleLog(`Part ${this.toJSON()} is available on server. Not re-uploading.`);\n                this.id = parts[0].part_id;\n                this.uploadSuccessHandler({\n                    data: {\n                        part: parts[0],\n                    },\n                });\n                return;\n            }\n\n            this.consoleLog(`Part ${this.toJSON()} is not available on server. Re-uploading.`);\n            throw new Error('Part not found on the server');\n        } catch (error) {\n            const { response } = error;\n            if (response && response.status) {\n                this.consoleLog(`Error ${response.status} while listing part ${this.toJSON()}. Re-uploading.`);\n            }\n\n            this.numUploadRetriesPerformed += 1;\n            this.upload();\n        }\n    };\n\n    /**\n     * Cancels upload for this Part.\n     *\n     * @return {void}\n     */\n    cancel(): void {\n        clearTimeout(this.retryTimeout);\n        this.blob = null;\n        this.data = {};\n        this.destroy();\n    }\n\n    /**\n     * Pauses upload for this Part.\n     *\n     * @return {void}\n     */\n    pause(): void {\n        clearTimeout(this.retryTimeout); // Cancel timeout so that we don't keep retrying while paused\n        this.isPaused = true;\n        this.state = PART_STATE_DIGEST_READY;\n        this.xhr.abort(); //  This calls the error handler.\n    }\n\n    /**\n     * Unpauses upload for this Part.\n     *\n     * @return {void}\n     */\n    unpause(): void {\n        this.isPaused = false;\n        this.state = PART_STATE_UPLOADING;\n        this.retryUpload();\n    }\n\n    /**\n     * Resets upload for this Part.\n     *\n     * @return {void}\n     */\n    reset(): void {\n        this.numUploadRetriesPerformed = 0;\n        this.timing = {};\n        this.uploadedBytes = 0;\n    }\n\n    /**\n     * Checks if this Part is destroyed or paused\n     *\n     * @return {boolean}\n     */\n    isDestroyedOrPaused(): boolean {\n        return this.isDestroyed() || this.isPaused;\n    }\n\n    /**\n     * List specified parts\n     *\n     * @param {number} partIndex - Index of starting part. Optional.\n     * @param {number} limit - Number of parts to be listed. Optional.\n     * @return {Promise<Array<Object>>} Array of parts\n     */\n    listParts = async (partIndex: number, limit: number): Promise<Array<Object>> => {\n        const params = {\n            offset: partIndex,\n            limit,\n        };\n\n        const endpoint = updateQueryParameters(this.sessionEndpoints.listParts, params);\n        const response = await this.xhr.get({\n            url: endpoint,\n        });\n\n        return response.data.entries;\n    };\n}\n\nexport default MultiputPart;\nexport { PART_STATE_NOT_STARTED, PART_STATE_DIGEST_READY, PART_STATE_UPLOADING, PART_STATE_UPLOADED };\n"],"file":"MultiputPart.js"}