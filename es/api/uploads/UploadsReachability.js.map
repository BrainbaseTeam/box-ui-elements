{"version":3,"sources":["../../../src/api/uploads/UploadsReachability.js"],"names":["axios","LocalStore","DEFAULT_HOSTNAME_UPLOAD","DEFAULT_HOSTNAME_UPLOAD_APP","HEADER_CONTENT_TYPE","CACHED_RESULTS_LOCAL_STORE_KEY","UploadsReachability","localStore","cachedResults","populateCachedResultsWithValidLocalStoreValues","saveCachedResultsToLocalStore","getItem","setItem","result","expirationTimestampMS","Date","now","uploadHost","isCachedHostValid","isHostReachable","isReachable","localStoreResults","getCachedResultsFromLocalStore","Object","keys","forEach","unreachableHosts","value","push","cachedResult","getCachedResult","makeReachabilityRequest","updateCachedResult","url","headers","data","post"],"mappings":";;;;;;;;;;;;AAAA;;;;;AAMA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,UAAP,MAAuB,wBAAvB;AACA,SAASC,uBAAT,EAAkCC,2BAAlC,EAA+DC,mBAA/D,QAA0F,iBAA1F;AAGA,IAAMC,8BAA8B,GAAG,yCAAvC;;IAOMC,mB;;;AAKF;;;AAGA,iCAAc;AAAA;;AACV,SAAKC,UAAL,GAAkB,IAAIN,UAAJ,EAAlB;AACA,SAAKO,aAAL,GAAqB,EAArB,CAFU,CAIV;AACA;AACA;AACA;;AACA,SAAKC,8CAAL;AACA,SAAKC,6BAAL;AACH;AAED;;;;;;;;;;qDAMiC;AAC7B,aAAO,KAAKH,UAAL,CAAgBI,OAAhB,CAAwBN,8BAAxB,CAAP;AACH;AAED;;;;;;;;;oDAMgC;AAC5B,WAAKE,UAAL,CAAgBK,OAAhB,CAAwBP,8BAAxB,EAAwD,KAAKG,aAA7D;AACH;AAED;;;;;;;;;;sCAOkBK,M,EAAsB;AACpC,aAAOA,MAAM,CAACC,qBAAP,GAA+BC,IAAI,CAACC,GAAL,EAAtC;AACH;AAED;;;;;;;;;;oCAOgBC,U,EAAoB;AAChC,UAAIA,UAAU,IAAI,KAAKT,aAAvB,EAAsC;AAClC,YAAMK,MAAM,GAAG,KAAKL,aAAL,CAAmBS,UAAnB,CAAf;;AACA,YAAI,KAAKC,iBAAL,CAAuBL,MAAvB,CAAJ,EAAoC;AAChC,iBAAOA,MAAP;AACH;AACJ;;AAED,aAAO,IAAP;AACH;AAED;;;;;;;;;;;uCAQmBI,U,EAAoBE,e,EAA0B;AAC7D,WAAKX,aAAL,CAAmBS,UAAnB,IAAiC;AAC7BG,QAAAA,WAAW,EAAED,eADgB;AAE7BL,QAAAA,qBAAqB,EAAEC,IAAI,CAACC,GAAL,KAAa,OAAO;AAFd,OAAjC;AAIA,WAAKN,6BAAL;AACH;AAED;;;;;;;;;qEAMiD;AAAA;;AAC7C,UAAMW,iBAAiB,GAAG,KAAKC,8BAAL,EAA1B;;AACA,UAAI,CAACD,iBAAL,EAAwB;AACpB;AACH;;AAEDE,MAAAA,MAAM,CAACC,IAAP,CAAYH,iBAAZ,EAA+BI,OAA/B,CAAuC,UAAAR,UAAU,EAAI;AACjD,YAAMJ,MAAM,GAAGQ,iBAAiB,CAACJ,UAAD,CAAhC;;AACA,YAAI,KAAI,CAACC,iBAAL,CAAuBL,MAAvB,CAAJ,EAAoC;AAChC,UAAA,KAAI,CAACL,aAAL,CAAmBS,UAAnB,IAAiCJ,MAAjC;AACH;AACJ,OALD;AAMH;AAED;;;;;;;;8CAK0B;AAAA;;AACtB,UAAMa,gBAAgB,GAAG,EAAzB;;AACA,UAAI,CAAC,KAAKlB,aAAV,EAAyB;AACrB,eAAOkB,gBAAP;AACH;;AAEDH,MAAAA,MAAM,CAACC,IAAP,CAAY,KAAKhB,aAAjB,EAAgCiB,OAAhC,CAAwC,UAAAR,UAAU,EAAI;AAClD,YAAMU,KAAK,GAAG,MAAI,CAACnB,aAAL,CAAmBS,UAAnB,CAAd;;AACA,YAAI,MAAI,CAACC,iBAAL,CAAuBS,KAAvB,KAAiC,CAACA,KAAK,CAACP,WAA5C,EAAyD;AACrDM,UAAAA,gBAAgB,CAACE,IAAjB,CAAsBX,UAAtB;AACH;AACJ,OALD;AAOA,aAAOS,gBAAP;AACH;AAED;;;;;;;;;;;;;;+CAQkBT,U;;;;;;sBAEVA,UAAU,eAAQf,uBAAR,MAAV,IAAgDe,UAAU,eAAQd,2BAAR,M;;;;;iDACnD,I;;;AAGL0B,gBAAAA,Y,GAAe,KAAKC,eAAL,CAAqBb,UAArB,C;;qBACjBY,Y;;;;;iDACOA,YAAY,CAACT,W;;;;uBAGM,KAAKW,uBAAL,CAA6Bd,UAA7B,C;;;AAAxBE,gBAAAA,e;AACN,qBAAKa,kBAAL,CAAwBf,UAAxB,EAAoCE,eAApC;iDACOA,e;;;;;;;;;;;;;;;;AAGX;;;;;;;;;;;;;gDAO8BF,U;;;;;;;;AACpBgB,gBAAAA,G,aAAShB,U;AACTiB,gBAAAA,O,6CACD9B,mB,EAAsB,kD,6BACvB,a,EAAe,6B,6BACf,a,EAAe,M;AAEb+B,gBAAAA,I,GAAO,kC;;;uBAGHnC,KAAK,CAACoC,IAAN,CAAWH,GAAX,EAAgBE,IAAhB,EAAsB;AAAED,kBAAAA,OAAO,EAAPA;AAAF,iBAAtB,C;;;;;;;;;kDAEC,K;;;kDAGJ,I;;;;;;;;;;;;;;;;;;;;;AAIf,eAAe5B,mBAAf","sourcesContent":["/**\n * @flow\n * @file Helper for Box uploads reachability test\n * @author Box\n */\n\nimport axios from 'axios';\nimport LocalStore from '../../utils/LocalStore';\nimport { DEFAULT_HOSTNAME_UPLOAD, DEFAULT_HOSTNAME_UPLOAD_APP, HEADER_CONTENT_TYPE } from '../../constants';\nimport type { StringAnyMap, StringMap } from '../../common/types/core';\n\nconst CACHED_RESULTS_LOCAL_STORE_KEY = 'bcu-uploads-reachability-cached-results';\n\ntype CachedResult = {\n    expirationTimestampMS: number,\n    isReachable: boolean,\n};\n\nclass UploadsReachability {\n    localStore: LocalStore;\n\n    cachedResults: { string: CachedResult };\n\n    /**\n     * [constructor]\n     */\n    constructor() {\n        this.localStore = new LocalStore();\n        this.cachedResults = {};\n\n        // Populate cachedResults with valid values from the local store, and then save the new\n        // cachedResults back to local store.\n        // This cleanup of invalid entries is not strictly necessary to maintain correctness,\n        // but if we don't do this cleanup results may accumulate in local storage forever.\n        this.populateCachedResultsWithValidLocalStoreValues();\n        this.saveCachedResultsToLocalStore();\n    }\n\n    /**\n     * Returns existing reachability results from local store\n     *\n     * @private\n     * @return {?Object} The results, or null if there was a problem reading the value from local store\n     */\n    getCachedResultsFromLocalStore() {\n        return this.localStore.getItem(CACHED_RESULTS_LOCAL_STORE_KEY);\n    }\n\n    /**\n     * Saves the cachedResults variable as a JSON string in local store.\n     *\n     * @private\n     * @return {void}\n     */\n    saveCachedResultsToLocalStore() {\n        this.localStore.setItem(CACHED_RESULTS_LOCAL_STORE_KEY, this.cachedResults);\n    }\n\n    /**\n     * Returns true if the given cached result is still valid (i.e. it has not expired yet)\n     *\n     * @private\n     * @param {StringAnyMap} result - A result object for one host\n     * @return {boolean} Whether or not the result is valid\n     */\n    isCachedHostValid(result: StringAnyMap) {\n        return result.expirationTimestampMS > Date.now();\n    }\n\n    /**\n     * Returns the cached result for the given uploadHost\n     *\n     * @private\n     * @param {string} uploadHost - The host URL\n     * @return {null|StringAnyMap} The result object or null if there isn't one\n     */\n    getCachedResult(uploadHost: string) {\n        if (uploadHost in this.cachedResults) {\n            const result = this.cachedResults[uploadHost];\n            if (this.isCachedHostValid(result)) {\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Updates a cached result. Changes both the in-memory cachedResult variable and what's stored in local store\n     *\n     * @private\n     * @param {string} uploadHost - The host URL that was tested\n     * @param {boolean} isHostReachable - Whether or not the host was reachable\n     * @return {void}\n     */\n    updateCachedResult(uploadHost: string, isHostReachable: boolean) {\n        this.cachedResults[uploadHost] = {\n            isReachable: isHostReachable,\n            expirationTimestampMS: Date.now() + 1000 * 86400,\n        };\n        this.saveCachedResultsToLocalStore();\n    }\n\n    /**\n     * Adds to the cachedResults object with valid entries from local storage\n     *\n     * @private\n     * @return {void}\n     */\n    populateCachedResultsWithValidLocalStoreValues() {\n        const localStoreResults = this.getCachedResultsFromLocalStore();\n        if (!localStoreResults) {\n            return;\n        }\n\n        Object.keys(localStoreResults).forEach(uploadHost => {\n            const result = localStoreResults[uploadHost];\n            if (this.isCachedHostValid(result)) {\n                this.cachedResults[uploadHost] = result;\n            }\n        });\n    }\n\n    /**\n     * Returns the host URLs that, according to the cached reachability test results, are unreachable\n     *\n     * @return {Array} The unreachable host URLs\n     */\n    getUnreachableHostsUrls() {\n        const unreachableHosts = [];\n        if (!this.cachedResults) {\n            return unreachableHosts;\n        }\n\n        Object.keys(this.cachedResults).forEach(uploadHost => {\n            const value = this.cachedResults[uploadHost];\n            if (this.isCachedHostValid(value) && !value.isReachable) {\n                unreachableHosts.push(uploadHost);\n            }\n        });\n\n        return unreachableHosts;\n    }\n\n    /**\n     * Determines whether the given host is reachable by either making a test request to the uploadHost\n     * or returning the result of the last reachability test it did\n     *\n     * @param {string} uploadHost - The upload host URL that will be stored in the cached test result and returned in\n     * getUnreachableHostsUrls() if test fails (this is usually a prefix of the uploadUrl)\n     * @return {Promise<boolean>} Promise that resolved to true if the host is reachable, false if it is not\n     */\n    async isReachable(uploadHost: string) {\n        // The default upload host should always reachable\n        if (uploadHost === `${DEFAULT_HOSTNAME_UPLOAD}/` || uploadHost === `${DEFAULT_HOSTNAME_UPLOAD_APP}/`) {\n            return true;\n        }\n\n        const cachedResult = this.getCachedResult(uploadHost);\n        if (cachedResult) {\n            return cachedResult.isReachable;\n        }\n\n        const isHostReachable = await this.makeReachabilityRequest(uploadHost);\n        this.updateCachedResult(uploadHost, isHostReachable);\n        return isHostReachable;\n    }\n\n    /**\n     * Determines if the given uploadHost is reachable by making a test upload request to it.\n     * Does not read or modify any cached results.\n     *\n     * @param {string} uploadHost - The upload host url to make a test request against\n     * @return {Promise<boolean>}\n     */\n    async makeReachabilityRequest(uploadHost: string) {\n        const url = `${uploadHost}html5?reachability_test=run`;\n        const headers: StringMap = {\n            [HEADER_CONTENT_TYPE]: 'application/x-www-form-urlencoded; charset=UTF-8',\n            'X-File-Name': 'reachability_pseudofile.txt',\n            'X-File-Size': '1234',\n        };\n        const data = 'reachability_file=test_file_data';\n\n        try {\n            await axios.post(url, data, { headers });\n        } catch (error) {\n            return false;\n        }\n\n        return true;\n    }\n}\n\nexport default UploadsReachability;\n"],"file":"UploadsReachability.js"}